var documenterSearchIndex = {"docs":
[{"location":"api/#API-Reference","page":"API","title":"API Reference","text":"Pages = [\"api.md\"]","category":"section"},{"location":"api/#Task-Types","page":"API","title":"Task Types","text":"","category":"section"},{"location":"api/#Channel-Types","page":"API","title":"Channel Types","text":"","category":"section"},{"location":"api/#Enumerations","page":"API","title":"Enumerations","text":"","category":"section"},{"location":"api/#Device-Functions","page":"API","title":"Device Functions","text":"","category":"section"},{"location":"api/#Task-Lifecycle","page":"API","title":"Task Lifecycle","text":"","category":"section"},{"location":"api/#Analog-Input-Channels","page":"API","title":"Analog Input Channels","text":"","category":"section"},{"location":"api/#Analog-Output-Channels","page":"API","title":"Analog Output Channels","text":"","category":"section"},{"location":"api/#Digital-Channels","page":"API","title":"Digital Channels","text":"","category":"section"},{"location":"api/#Counter-Input-Channels","page":"API","title":"Counter Input Channels","text":"","category":"section"},{"location":"api/#Counter-Output-Channels","page":"API","title":"Counter Output Channels","text":"","category":"section"},{"location":"api/#Read/Write-Operations","page":"API","title":"Read/Write Operations","text":"","category":"section"},{"location":"api/#Timing-Configuration","page":"API","title":"Timing Configuration","text":"","category":"section"},{"location":"api/#Buffer-Configuration","page":"API","title":"Buffer Configuration","text":"","category":"section"},{"location":"api/#Trigger-Configuration","page":"API","title":"Trigger Configuration","text":"","category":"section"},{"location":"api/#Properties","page":"API","title":"Properties","text":"","category":"section"},{"location":"api/#Library-Information","page":"API","title":"Library Information","text":"","category":"section"},{"location":"api/#Error-Handling","page":"API","title":"Error Handling","text":"","category":"section"},{"location":"api/#DAQmx.Task","page":"API","title":"DAQmx.Task","text":"Task{K<:TaskKind}\n\nAn NI-DAQmx task with parametric type for the task kind. This allows for type-safe dispatch on different task types.\n\nFields\n\nhandle::TaskHandle: The underlying NI-DAQmx task handle.\nname::String: The name of the task.\n\nType Aliases\n\nAITask = Task{AnalogInputKind}\nAOTask = Task{AnalogOutputKind}\nDITask = Task{DigitalInputKind}\nDOTask = Task{DigitalOutputKind}\nCITask = Task{CounterInputKind}\nCOTask = Task{CounterOutputKind}\n\n\n\n\n\n","category":"type"},{"location":"api/#DAQmx.TaskKind","page":"API","title":"DAQmx.TaskKind","text":"TaskKind\n\nAbstract supertype for task kind type parameters.\n\n\n\n\n\n","category":"type"},{"location":"api/#DAQmx.AbstractChannel","page":"API","title":"DAQmx.AbstractChannel","text":"AbstractChannel\n\nAbstract supertype for all channel types.\n\n\n\n\n\n","category":"type"},{"location":"api/#DAQmx.AnalogChannel","page":"API","title":"DAQmx.AnalogChannel","text":"AnalogChannel <: AbstractChannel\n\nRepresents an analog channel (input or output).\n\nFields\n\nphysical_channel::String: The physical channel name (e.g., \"Dev1/ai0\").\nname::String: The assigned name for the channel.\n\n\n\n\n\n","category":"type"},{"location":"api/#DAQmx.DigitalChannel","page":"API","title":"DAQmx.DigitalChannel","text":"DigitalChannel <: AbstractChannel\n\nRepresents a digital channel (input or output).\n\nFields\n\nlines::String: The digital lines (e.g., \"Dev1/port0/line0:7\").\nname::String: The assigned name for the channel.\n\n\n\n\n\n","category":"type"},{"location":"api/#DAQmx.CounterChannel","page":"API","title":"DAQmx.CounterChannel","text":"CounterChannel <: AbstractChannel\n\nRepresents a counter channel (input or output).\n\nFields\n\ncounter::String: The counter name (e.g., \"Dev1/ctr0\").\nname::String: The assigned name for the channel.\n\n\n\n\n\n","category":"type"},{"location":"api/#DAQmx.TerminalConfig","page":"API","title":"DAQmx.TerminalConfig","text":"TerminalConfig\n\nTerminal configuration for analog input channels.\n\n\n\n\n\n","category":"type"},{"location":"api/#DAQmx.Edge","page":"API","title":"DAQmx.Edge","text":"Edge\n\nEdge type for triggers and timing.\n\n\n\n\n\n","category":"type"},{"location":"api/#DAQmx.SampleMode","page":"API","title":"DAQmx.SampleMode","text":"SampleMode\n\nSample acquisition mode.\n\n\n\n\n\n","category":"type"},{"location":"api/#DAQmx.FillMode","page":"API","title":"DAQmx.FillMode","text":"FillMode\n\nData layout for read/write operations.\n\n\n\n\n\n","category":"type"},{"location":"api/#DAQmx.LineGrouping","page":"API","title":"DAQmx.LineGrouping","text":"LineGrouping\n\nDigital line grouping mode.\n\n\n\n\n\n","category":"type"},{"location":"api/#DAQmx.CountDirection","page":"API","title":"DAQmx.CountDirection","text":"CountDirection\n\nDirection for counter channels.\n\n\n\n\n\n","category":"type"},{"location":"api/#DAQmx.Level","page":"API","title":"DAQmx.Level","text":"Level\n\nLogic level.\n\n\n\n\n\n","category":"type"},{"location":"api/#DAQmx.Coupling","page":"API","title":"DAQmx.Coupling","text":"Coupling\n\nInput coupling mode.\n\n\n\n\n\n","category":"type"},{"location":"api/#DAQmx.EncoderType","page":"API","title":"DAQmx.EncoderType","text":"EncoderType\n\nEncoder decoding type for angular/linear encoders.\n\n\n\n\n\n","category":"type"},{"location":"api/#DAQmx.ZIndexPhase","page":"API","title":"DAQmx.ZIndexPhase","text":"ZIndexPhase\n\nZ-index phase for encoders.\n\n\n\n\n\n","category":"type"},{"location":"api/#DAQmx.ExcitationSource","page":"API","title":"DAQmx.ExcitationSource","text":"ExcitationSource\n\nExcitation source for sensors.\n\n\n\n\n\n","category":"type"},{"location":"api/#DAQmx.ResistanceConfig","page":"API","title":"DAQmx.ResistanceConfig","text":"ResistanceConfig\n\nResistance measurement configuration.\n\n\n\n\n\n","category":"type"},{"location":"api/#DAQmx.Slope","page":"API","title":"DAQmx.Slope","text":"Slope\n\nSlope for analog triggers.\n\n\n\n\n\n","category":"type"},{"location":"api/#DAQmx.Device","page":"API","title":"DAQmx.Device","text":"Device\n\nRepresents a NI-DAQmx device.\n\nFields\n\nname::String: The device name (e.g., \"Dev1\").\n\n\n\n\n\n","category":"type"},{"location":"api/#DAQmx.devices","page":"API","title":"DAQmx.devices","text":"devices() -> Vector{Device}\n\nGet a list of all available NI-DAQmx devices.\n\nReturns\n\nA vector of Device objects representing available devices.\n\nExample\n\njulia> devs = devices()\n2-element Vector{Device}:\n Device(\"Dev1\")\n Device(\"Dev2\")\n\njulia> ai_channels(devs[1])\n[\"Dev1/ai0\", \"Dev1/ai1\", ...]\n\n\n\n\n\n","category":"function"},{"location":"api/#DAQmx.product_type","page":"API","title":"DAQmx.product_type","text":"product_type(device::Device) -> String\nproduct_type(device_name::String) -> String\n\nGet the product type of a device (e.g., \"USB-6001\").\n\n\n\n\n\n","category":"function"},{"location":"api/#DAQmx.product_number","page":"API","title":"DAQmx.product_number","text":"product_number(device::Device) -> UInt32\nproduct_number(device_name::String) -> UInt32\n\nGet the product number of a device.\n\n\n\n\n\n","category":"function"},{"location":"api/#DAQmx.serial_number","page":"API","title":"DAQmx.serial_number","text":"serial_number(device::Device) -> UInt32\nserial_number(device_name::String) -> UInt32\n\nGet the serial number of a device.\n\n\n\n\n\n","category":"function"},{"location":"api/#DAQmx.is_simulated","page":"API","title":"DAQmx.is_simulated","text":"is_simulated(device::Device) -> Bool\nis_simulated(device_name::String) -> Bool\n\nCheck if a device is a simulated device.\n\n\n\n\n\n","category":"function"},{"location":"api/#DAQmx.ai_channels","page":"API","title":"DAQmx.ai_channels","text":"ai_channels(device::Device) -> Vector{String}\nai_channels(device_name::String) -> Vector{String}\n\nGet a list of analog input physical channels available on the device.\n\nExample\n\njulia> ai_channels(\"Dev1\")\n[\"Dev1/ai0\", \"Dev1/ai1\", \"Dev1/ai2\", \"Dev1/ai3\"]\n\n\n\n\n\n","category":"function"},{"location":"api/#DAQmx.ao_channels","page":"API","title":"DAQmx.ao_channels","text":"ao_channels(device::Device) -> Vector{String}\nao_channels(device_name::String) -> Vector{String}\n\nGet a list of analog output physical channels available on the device.\n\n\n\n\n\n","category":"function"},{"location":"api/#DAQmx.di_lines","page":"API","title":"DAQmx.di_lines","text":"di_lines(device::Device) -> Vector{String}\ndi_lines(device_name::String) -> Vector{String}\n\nGet a list of digital input lines available on the device.\n\n\n\n\n\n","category":"function"},{"location":"api/#DAQmx.do_lines","page":"API","title":"DAQmx.do_lines","text":"do_lines(device::Device) -> Vector{String}\ndo_lines(device_name::String) -> Vector{String}\n\nGet a list of digital output lines available on the device.\n\n\n\n\n\n","category":"function"},{"location":"api/#DAQmx.di_ports","page":"API","title":"DAQmx.di_ports","text":"di_ports(device::Device) -> Vector{String}\ndi_ports(device_name::String) -> Vector{String}\n\nGet a list of digital input ports available on the device.\n\n\n\n\n\n","category":"function"},{"location":"api/#DAQmx.do_ports","page":"API","title":"DAQmx.do_ports","text":"do_ports(device::Device) -> Vector{String}\ndo_ports(device_name::String) -> Vector{String}\n\nGet a list of digital output ports available on the device.\n\n\n\n\n\n","category":"function"},{"location":"api/#DAQmx.ci_channels","page":"API","title":"DAQmx.ci_channels","text":"ci_channels(device::Device) -> Vector{String}\nci_channels(device_name::String) -> Vector{String}\n\nGet a list of counter input physical channels available on the device.\n\n\n\n\n\n","category":"function"},{"location":"api/#DAQmx.co_channels","page":"API","title":"DAQmx.co_channels","text":"co_channels(device::Device) -> Vector{String}\nco_channels(device_name::String) -> Vector{String}\n\nGet a list of counter output physical channels available on the device.\n\n\n\n\n\n","category":"function"},{"location":"api/#DAQmx.terminals","page":"API","title":"DAQmx.terminals","text":"terminals(device::Device) -> Vector{String}\nterminals(device_name::String) -> Vector{String}\n\nGet a list of terminals available on the device.\n\n\n\n\n\n","category":"function"},{"location":"api/#DAQmx.ai_voltage_ranges","page":"API","title":"DAQmx.ai_voltage_ranges","text":"ai_voltage_ranges(device::Device) -> Matrix{Float64}\nai_voltage_ranges(device_name::String) -> Matrix{Float64}\n\nGet the available voltage ranges for analog input channels.\n\nReturns\n\nA matrix where each row is [min, max] for a voltage range.\n\nExample\n\njulia> ai_voltage_ranges(\"Dev1\")\n4Ã—2 Matrix{Float64}:\n -10.0  10.0\n  -5.0   5.0\n  -1.0   1.0\n  -0.2   0.2\n\n\n\n\n\n","category":"function"},{"location":"api/#DAQmx.ao_voltage_ranges","page":"API","title":"DAQmx.ao_voltage_ranges","text":"ao_voltage_ranges(device::Device) -> Matrix{Float64}\nao_voltage_ranges(device_name::String) -> Matrix{Float64}\n\nGet the available voltage ranges for analog output channels.\n\n\n\n\n\n","category":"function"},{"location":"api/#DAQmx.ai_current_ranges","page":"API","title":"DAQmx.ai_current_ranges","text":"ai_current_ranges(device::Device) -> Matrix{Float64}\nai_current_ranges(device_name::String) -> Matrix{Float64}\n\nGet the available current ranges for analog input channels.\n\n\n\n\n\n","category":"function"},{"location":"api/#DAQmx.ao_current_ranges","page":"API","title":"DAQmx.ao_current_ranges","text":"ao_current_ranges(device::Device) -> Matrix{Float64}\nao_current_ranges(device_name::String) -> Matrix{Float64}\n\nGet the available current ranges for analog output channels.\n\n\n\n\n\n","category":"function"},{"location":"api/#DAQmx.self_calibrate!","page":"API","title":"DAQmx.self_calibrate!","text":"self_calibrate!(device::Device)\nself_calibrate!(device_name::String)\n\nPerform self-calibration on the device.\n\n\n\n\n\n","category":"function"},{"location":"api/#DAQmx.reset!","page":"API","title":"DAQmx.reset!","text":"reset!(device::Device)\nreset!(device_name::String)\n\nReset the device to its default state.\n\n\n\n\n\n","category":"function"},{"location":"api/#DAQmx.start!","page":"API","title":"DAQmx.start!","text":"start!(task::Task)\n\nStart the specified task. The task begins performing its configured operations.\n\nArguments\n\ntask::Task: The task to start.\n\nThrows\n\nNIDAQError: If the task cannot be started.\n\nExample\n\ntask = AITask(\"Dev1/ai0\")\nconfigure_timing!(task; rate=1000.0, samples_per_channel=100)\nstart!(task)\ndata = read(task)\nstop!(task)\n\n\n\n\n\n","category":"function"},{"location":"api/#DAQmx.stop!","page":"API","title":"DAQmx.stop!","text":"stop!(task::Task)\n\nStop the specified task. The task stops performing its operations but remains configured.\n\nArguments\n\ntask::Task: The task to stop.\n\nThrows\n\nNIDAQError: If the task cannot be stopped.\n\n\n\n\n\n","category":"function"},{"location":"api/#DAQmx.clear!","page":"API","title":"DAQmx.clear!","text":"clear!(task::Task)\n\nClear the specified task, releasing all resources associated with it. After clearing, the task handle is no longer valid.\n\nArguments\n\ntask::Task: The task to clear.\n\nNote\n\nThis is typically called automatically by the finalizer, but can be called explicitly if you want to release resources immediately.\n\n\n\n\n\n","category":"function"},{"location":"api/#DAQmx.wait_until_done","page":"API","title":"DAQmx.wait_until_done","text":"wait_until_done(task::Task; timeout::Float64=-1.0)\n\nWait until the task has completed all operations.\n\nArguments\n\ntask::Task: The task to wait on.\ntimeout::Float64: Maximum time to wait in seconds. Use -1.0 to wait indefinitely.\n\nThrows\n\nNIDAQError: If the wait times out or encounters an error.\n\nExample\n\ntask = AOTask(\"Dev1/ao0\")\nconfigure_timing!(task; rate=1000.0, samples_per_channel=100)\nwrite(task, data)\nstart!(task)\nwait_until_done(task)\nstop!(task)\n\n\n\n\n\n","category":"function"},{"location":"api/#DAQmx.is_done","page":"API","title":"DAQmx.is_done","text":"is_done(task::Task) -> Bool\n\nCheck if the task has completed all operations.\n\nArguments\n\ntask::Task: The task to check.\n\nReturns\n\ntrue if the task is done, false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"api/#DAQmx.control!","page":"API","title":"DAQmx.control!","text":"control!(task::Task, action::Symbol)\n\nPerform a control action on the task.\n\nArguments\n\ntask::Task: The task to control.\naction::Symbol: The action to perform. One of:\n:start: Start the task\n:stop: Stop the task\n:verify: Verify the task configuration\n:commit: Commit the task (transition to committed state)\n:reserve: Reserve task resources\n:unreserve: Unreserve task resources\n:abort: Abort the task\n\nThrows\n\nNIDAQError: If the action fails.\nArgumentError: If the action is not recognized.\n\n\n\n\n\n","category":"function"},{"location":"api/#DAQmx.num_channels","page":"API","title":"DAQmx.num_channels","text":"num_channels(task::Task) -> Int\n\nGet the number of channels in the task.\n\nArguments\n\ntask::Task: The task to query.\n\nReturns\n\nThe number of channels in the task.\n\n\n\n\n\n","category":"function"},{"location":"api/#DAQmx.task_name","page":"API","title":"DAQmx.task_name","text":"task_name(task::Task) -> String\n\nGet the name of the task.\n\n\n\n\n\n","category":"function"},{"location":"api/#DAQmx.channel_names","page":"API","title":"DAQmx.channel_names","text":"channel_names(task::Task) -> Vector{String}\n\nGet the names of all channels in the task.\n\nReturns\n\nA vector of channel names.\n\n\n\n\n\n","category":"function"},{"location":"api/#DAQmx.device_names","page":"API","title":"DAQmx.device_names","text":"device_names(task::Task) -> Vector{String}\n\nGet the names of all devices used by the task.\n\nReturns\n\nA vector of device names.\n\n\n\n\n\ndevice_names() -> Vector{String}\n\nGet a list of all available device names as strings.\n\n\n\n\n\n","category":"function"},{"location":"api/#DAQmx.add_ai_voltage!","page":"API","title":"DAQmx.add_ai_voltage!","text":"add_ai_voltage!(task::AITask, channel::String;\n                terminal_config::TerminalConfig=Differential,\n                min_val::Float64=-10.0,\n                max_val::Float64=10.0,\n                units::Symbol=:Volts,\n                name::String=\"\",\n                custom_scale::String=\"\")\n\nAdd an analog input voltage channel to the task.\n\nArguments\n\ntask::AITask: The analog input task.\nchannel::String: Physical channel name (e.g., \"Dev1/ai0\" or \"Dev1/ai0:3\").\n\nKeyword Arguments\n\nterminal_config::TerminalConfig: Terminal configuration (default: Differential). Options: TerminalDefault, RSE, NRSE, Differential, PseudoDifferential.\nmin_val::Float64: Minimum expected value in units (default: -10.0).\nmax_val::Float64: Maximum expected value in units (default: 10.0).\nunits::Symbol: Units for the measurement (default: :Volts). Options: :Volts, :FromCustomScale.\nname::String: Name to assign to the channel (default: \"\").\ncustom_scale::String: Name of custom scale to use if units is :FromCustomScale.\n\nExample\n\ntask = AITask()\nadd_ai_voltage!(task, \"Dev1/ai0\"; terminal_config=RSE, min_val=-5.0, max_val=5.0)\nadd_ai_voltage!(task, \"Dev1/ai1\"; terminal_config=RSE, min_val=-5.0, max_val=5.0)\n\n\n\n\n\n","category":"function"},{"location":"api/#DAQmx.add_ai_current!","page":"API","title":"DAQmx.add_ai_current!","text":"add_ai_current!(task::AITask, channel::String;\n                terminal_config::TerminalConfig=Differential,\n                min_val::Float64=-0.01,\n                max_val::Float64=0.01,\n                units::Symbol=:Amps,\n                shunt_resistor_loc::Symbol=:Default,\n                ext_shunt_resistor_val::Float64=249.0,\n                name::String=\"\",\n                custom_scale::String=\"\")\n\nAdd an analog input current channel to the task.\n\nArguments\n\ntask::AITask: The analog input task.\nchannel::String: Physical channel name.\n\nKeyword Arguments\n\nterminal_config::TerminalConfig: Terminal configuration (default: Differential).\nmin_val::Float64: Minimum expected current in units (default: -0.01).\nmax_val::Float64: Maximum expected current in units (default: 0.01).\nunits::Symbol: Units for the measurement (default: :Amps).\nshunt_resistor_loc::Symbol: Location of shunt resistor (:Default, :Internal, :External).\next_shunt_resistor_val::Float64: External shunt resistor value in ohms.\nname::String: Name to assign to the channel.\ncustom_scale::String: Name of custom scale.\n\n\n\n\n\n","category":"function"},{"location":"api/#DAQmx.add_ai_thermocouple!","page":"API","title":"DAQmx.add_ai_thermocouple!","text":"add_ai_thermocouple!(task::AITask, channel::String;\n                     min_val::Float64=0.0,\n                     max_val::Float64=100.0,\n                     units::Symbol=:DegC,\n                     thermocouple_type::Symbol=:K_Type,\n                     cjc_source::Symbol=:BuiltIn,\n                     cjc_val::Float64=25.0,\n                     cjc_channel::String=\"\",\n                     name::String=\"\")\n\nAdd a thermocouple input channel to the task.\n\nKeyword Arguments\n\nunits::Symbol: Temperature units (:DegC, :DegF, :Kelvins, :DegR).\nthermocouple_type::Symbol: Type of thermocouple (:J_Type, :K_Type, :N_Type, :R_Type, :S_Type, :T_Type, :B_Type, :E_Type).\ncjc_source::Symbol: Cold junction compensation source (:BuiltIn, :ConstVal, :Chan).\ncjc_val::Float64: Cold junction temperature if cjc_source is :ConstVal.\ncjc_channel::String: CJC channel name if cjc_source is :Chan.\n\n\n\n\n\n","category":"function"},{"location":"api/#DAQmx.add_ai_rtd!","page":"API","title":"DAQmx.add_ai_rtd!","text":"add_ai_rtd!(task::AITask, channel::String;\n            min_val::Float64=0.0,\n            max_val::Float64=100.0,\n            units::Symbol=:DegC,\n            rtd_type::Symbol=:Pt3851,\n            resistance_config::ResistanceConfig=FourWire,\n            current_excit_source::ExcitationSource=ExcitationInternal,\n            current_excit_val::Float64=0.001,\n            r0::Float64=100.0,\n            name::String=\"\")\n\nAdd an RTD (Resistance Temperature Detector) input channel.\n\n\n\n\n\n","category":"function"},{"location":"api/#DAQmx.add_ai_resistance!","page":"API","title":"DAQmx.add_ai_resistance!","text":"add_ai_resistance!(task::AITask, channel::String;\n                   min_val::Float64=0.0,\n                   max_val::Float64=1000.0,\n                   units::Symbol=:Ohms,\n                   resistance_config::ResistanceConfig=TwoWire,\n                   current_excit_source::ExcitationSource=ExcitationInternal,\n                   current_excit_val::Float64=0.001,\n                   name::String=\"\",\n                   custom_scale::String=\"\")\n\nAdd a resistance measurement channel.\n\n\n\n\n\n","category":"function"},{"location":"api/#DAQmx.add_ai_accel!","page":"API","title":"DAQmx.add_ai_accel!","text":"add_ai_accel!(task::AITask, channel::String;\n              terminal_config::TerminalConfig=Differential,\n              min_val::Float64=-5.0,\n              max_val::Float64=5.0,\n              units::Symbol=:g,\n              sensitivity::Float64=100.0,\n              sensitivity_units::Symbol=:mVoltsPerG,\n              current_excit_source::ExcitationSource=ExcitationInternal,\n              current_excit_val::Float64=0.002,\n              name::String=\"\",\n              custom_scale::String=\"\")\n\nAdd an accelerometer input channel.\n\nKeyword Arguments\n\nsensitivity::Float64: Sensor sensitivity (default: 100.0 mV/g).\nsensitivity_units::Symbol: Units for sensitivity (:mVoltsPerG, :VoltsPerG).\n\n\n\n\n\n","category":"function"},{"location":"api/#DAQmx.add_ao_voltage!","page":"API","title":"DAQmx.add_ao_voltage!","text":"add_ao_voltage!(task::AOTask, channel::String;\n                min_val::Float64=-10.0,\n                max_val::Float64=10.0,\n                units::Symbol=:Volts,\n                name::String=\"\",\n                custom_scale::String=\"\")\n\nAdd an analog output voltage channel to the task.\n\nArguments\n\ntask::AOTask: The analog output task.\nchannel::String: Physical channel name (e.g., \"Dev1/ao0\").\n\nKeyword Arguments\n\nmin_val::Float64: Minimum output value in units (default: -10.0).\nmax_val::Float64: Maximum output value in units (default: 10.0).\nunits::Symbol: Units for output (default: :Volts).\nname::String: Name to assign to the channel.\ncustom_scale::String: Name of custom scale if units is :FromCustomScale.\n\nExample\n\ntask = AOTask()\nadd_ao_voltage!(task, \"Dev1/ao0\"; min_val=0.0, max_val=5.0)\n\n\n\n\n\n","category":"function"},{"location":"api/#DAQmx.add_ao_current!","page":"API","title":"DAQmx.add_ao_current!","text":"add_ao_current!(task::AOTask, channel::String;\n                min_val::Float64=0.0,\n                max_val::Float64=0.02,\n                units::Symbol=:Amps,\n                name::String=\"\",\n                custom_scale::String=\"\")\n\nAdd an analog output current channel to the task.\n\n\n\n\n\n","category":"function"},{"location":"api/#DAQmx.add_ao_funcgen!","page":"API","title":"DAQmx.add_ao_funcgen!","text":"add_ao_funcgen!(task::AOTask, channel::String;\n                type::Symbol=:Sine,\n                freq::Float64=1000.0,\n                amplitude::Float64=1.0,\n                offset::Float64=0.0,\n                name::String=\"\")\n\nAdd a function generator channel to the task.\n\nKeyword Arguments\n\ntype::Symbol: Waveform type (:Sine, :Triangle, :Square, :Sawtooth).\nfreq::Float64: Frequency in Hz.\namplitude::Float64: Peak-to-peak amplitude in volts.\noffset::Float64: DC offset in volts.\n\n\n\n\n\n","category":"function"},{"location":"api/#DAQmx.add_di_chan!","page":"API","title":"DAQmx.add_di_chan!","text":"add_di_chan!(task::DITask, lines::String;\n             line_grouping::LineGrouping=ChannelPerLine,\n             name::String=\"\")\n\nAdd digital input lines to the task.\n\nArguments\n\ntask::DITask: The digital input task.\nlines::String: Physical lines (e.g., \"Dev1/port0/line0:7\" or \"Dev1/port0\").\n\nKeyword Arguments\n\nline_grouping::LineGrouping: How to group lines (default: ChannelPerLine).\nChannelPerLine: Create one channel for each line.\nChannelForAllLines: Create one channel for all lines.\nname::String: Name to assign to the channel(s).\n\nExample\n\ntask = DITask()\nadd_di_chan!(task, \"Dev1/port0/line0:7\")\nstart!(task)\ndata = read(task)\n\n\n\n\n\n","category":"function"},{"location":"api/#DAQmx.add_do_chan!","page":"API","title":"DAQmx.add_do_chan!","text":"add_do_chan!(task::DOTask, lines::String;\n             line_grouping::LineGrouping=ChannelPerLine,\n             name::String=\"\")\n\nAdd digital output lines to the task.\n\nArguments\n\ntask::DOTask: The digital output task.\nlines::String: Physical lines (e.g., \"Dev1/port0/line0:7\" or \"Dev1/port0\").\n\nKeyword Arguments\n\nline_grouping::LineGrouping: How to group lines (default: ChannelPerLine).\nChannelPerLine: Create one channel for each line.\nChannelForAllLines: Create one channel for all lines.\nname::String: Name to assign to the channel(s).\n\nExample\n\ntask = DOTask()\nadd_do_chan!(task, \"Dev1/port0/line0:7\")\nwrite(task, UInt8[0xFF])\n\n\n\n\n\n","category":"function"},{"location":"api/#DAQmx.add_ci_count_edges!","page":"API","title":"DAQmx.add_ci_count_edges!","text":"add_ci_count_edges!(task::CITask, counter::String;\n                    edge::Edge=Rising,\n                    initial_count::UInt32=UInt32(0),\n                    count_direction::CountDirection=CountUp,\n                    name::String=\"\")\n\nAdd a counter input channel that counts edges.\n\nArguments\n\ntask::CITask: The counter input task.\ncounter::String: Counter name (e.g., \"Dev1/ctr0\").\n\nKeyword Arguments\n\nedge::Edge: Which edge to count (default: Rising).\ninitial_count::UInt32: Starting count value (default: 0).\ncount_direction::CountDirection: Count direction (default: CountUp).\nname::String: Name to assign to the channel.\n\nExample\n\ntask = CITask()\nadd_ci_count_edges!(task, \"Dev1/ctr0\"; edge=Rising, count_direction=CountUp)\nconfigure_timing!(task; sample_mode=ContinuousSamples)\nstart!(task)\ncounts = read(task; samples_per_channel=100)\n\n\n\n\n\n","category":"function"},{"location":"api/#DAQmx.add_ci_freq!","page":"API","title":"DAQmx.add_ci_freq!","text":"add_ci_freq!(task::CITask, counter::String;\n             min_val::Float64=1.0,\n             max_val::Float64=1000000.0,\n             units::Symbol=:Hz,\n             edge::Edge=Rising,\n             meas_method::Symbol=:LowFreq1Ctr,\n             meas_time::Float64=0.001,\n             divisor::UInt32=UInt32(4),\n             name::String=\"\",\n             custom_scale::String=\"\")\n\nAdd a counter input channel that measures frequency.\n\nKeyword Arguments\n\nmeas_method::Symbol: Measurement method (:LowFreq1Ctr, :HighFreq2Ctr, :LargeRng2Ctr).\nmeas_time::Float64: Measurement time for low frequency method (seconds).\ndivisor::UInt32: Divisor for high frequency method.\n\n\n\n\n\n","category":"function"},{"location":"api/#DAQmx.add_ci_period!","page":"API","title":"DAQmx.add_ci_period!","text":"add_ci_period!(task::CITask, counter::String;\n               min_val::Float64=0.000001,\n               max_val::Float64=1.0,\n               units::Symbol=:Seconds,\n               edge::Edge=Rising,\n               meas_method::Symbol=:LowFreq1Ctr,\n               meas_time::Float64=0.001,\n               divisor::UInt32=UInt32(4),\n               name::String=\"\",\n               custom_scale::String=\"\")\n\nAdd a counter input channel that measures period.\n\n\n\n\n\n","category":"function"},{"location":"api/#DAQmx.add_ci_pulse_width!","page":"API","title":"DAQmx.add_ci_pulse_width!","text":"add_ci_pulse_width!(task::CITask, counter::String;\n                    min_val::Float64=0.000001,\n                    max_val::Float64=1.0,\n                    units::Symbol=:Seconds,\n                    starting_edge::Edge=Rising,\n                    name::String=\"\",\n                    custom_scale::String=\"\")\n\nAdd a counter input channel that measures pulse width.\n\n\n\n\n\n","category":"function"},{"location":"api/#DAQmx.add_ci_two_edge_sep!","page":"API","title":"DAQmx.add_ci_two_edge_sep!","text":"add_ci_two_edge_sep!(task::CITask, counter::String;\n                     min_val::Float64=0.000001,\n                     max_val::Float64=1.0,\n                     units::Symbol=:Seconds,\n                     first_edge::Edge=Rising,\n                     second_edge::Edge=Falling,\n                     name::String=\"\",\n                     custom_scale::String=\"\")\n\nAdd a counter input channel that measures time between two edges.\n\n\n\n\n\n","category":"function"},{"location":"api/#DAQmx.add_ci_ang_encoder!","page":"API","title":"DAQmx.add_ci_ang_encoder!","text":"add_ci_ang_encoder!(task::CITask, counter::String;\n                    decoding_type::EncoderType=EncoderX4,\n                    z_idx_enable::Bool=true,\n                    z_idx_val::Float64=0.0,\n                    z_idx_phase::ZIndexPhase=AHighBHigh,\n                    units::Symbol=:Degrees,\n                    pulses_per_rev::UInt32=UInt32(1024),\n                    initial_angle::Float64=0.0,\n                    name::String=\"\",\n                    custom_scale::String=\"\")\n\nAdd an angular encoder input channel.\n\nKeyword Arguments\n\ndecoding_type::EncoderType: Encoder decoding (:EncoderX1, :EncoderX2, :EncoderX4, :TwoPulseCounting).\nz_idx_enable::Bool: Enable Z-index.\nz_idx_val::Float64: Z-index value.\nz_idx_phase::ZIndexPhase: Z-index phase.\npulses_per_rev::UInt32: Pulses per revolution.\ninitial_angle::Float64: Initial angle value.\n\n\n\n\n\n","category":"function"},{"location":"api/#DAQmx.add_ci_lin_encoder!","page":"API","title":"DAQmx.add_ci_lin_encoder!","text":"add_ci_lin_encoder!(task::CITask, counter::String;\n                    decoding_type::EncoderType=EncoderX4,\n                    z_idx_enable::Bool=false,\n                    z_idx_val::Float64=0.0,\n                    z_idx_phase::ZIndexPhase=AHighBHigh,\n                    units::Symbol=:Meters,\n                    dist_per_pulse::Float64=0.001,\n                    initial_pos::Float64=0.0,\n                    name::String=\"\",\n                    custom_scale::String=\"\")\n\nAdd a linear encoder input channel.\n\n\n\n\n\n","category":"function"},{"location":"api/#DAQmx.add_co_pulse_freq!","page":"API","title":"DAQmx.add_co_pulse_freq!","text":"add_co_pulse_freq!(task::COTask, counter::String;\n                   units::Symbol=:Hz,\n                   idle_state::Level=Low,\n                   initial_delay::Float64=0.0,\n                   freq::Float64=1000.0,\n                   duty_cycle::Float64=0.5,\n                   name::String=\"\")\n\nAdd a counter output pulse channel using frequency and duty cycle.\n\nArguments\n\ntask::COTask: The counter output task.\ncounter::String: Counter name (e.g., \"Dev1/ctr0\").\n\nKeyword Arguments\n\nunits::Symbol: Frequency units (:Hz).\nidle_state::Level: Idle state (Low or High).\ninitial_delay::Float64: Initial delay before first pulse (seconds).\nfreq::Float64: Pulse frequency in Hz.\nduty_cycle::Float64: Duty cycle (0.0 to 1.0).\n\nExample\n\ntask = COTask()\nadd_co_pulse_freq!(task, \"Dev1/ctr0\"; freq=1000.0, duty_cycle=0.5)\nconfigure_timing!(task; sample_mode=ContinuousSamples, samples_per_channel=1000)\nstart!(task)\n\n\n\n\n\n","category":"function"},{"location":"api/#DAQmx.add_co_pulse_time!","page":"API","title":"DAQmx.add_co_pulse_time!","text":"add_co_pulse_time!(task::COTask, counter::String;\n                   units::Symbol=:Seconds,\n                   idle_state::Level=Low,\n                   initial_delay::Float64=0.0,\n                   low_time::Float64=0.001,\n                   high_time::Float64=0.001,\n                   name::String=\"\")\n\nAdd a counter output pulse channel using high/low times.\n\nKeyword Arguments\n\nlow_time::Float64: Time the pulse is low (seconds).\nhigh_time::Float64: Time the pulse is high (seconds).\n\n\n\n\n\n","category":"function"},{"location":"api/#DAQmx.add_co_pulse_ticks!","page":"API","title":"DAQmx.add_co_pulse_ticks!","text":"add_co_pulse_ticks!(task::COTask, counter::String;\n                    source_terminal::String=\"\",\n                    idle_state::Level=Low,\n                    initial_delay::Int32=Int32(0),\n                    low_ticks::Int32=Int32(100),\n                    high_ticks::Int32=Int32(100),\n                    name::String=\"\")\n\nAdd a counter output pulse channel using tick counts.\n\nKeyword Arguments\n\nsource_terminal::String: Source terminal for the timebase.\nlow_ticks::Int32: Number of ticks the pulse is low.\nhigh_ticks::Int32: Number of ticks the pulse is high.\n\n\n\n\n\n","category":"function"},{"location":"api/#DAQmx.read_scalar","page":"API","title":"DAQmx.read_scalar","text":"read_scalar(task::AITask; timeout::Float64=10.0) -> Float64\n\nRead a single sample from an analog input task.\n\n\n\n\n\nread_scalar(task::DITask; timeout::Float64=10.0) -> UInt32\n\nRead a single digital sample.\n\n\n\n\n\nread_scalar(task::CITask; timeout::Float64=10.0) -> UInt32\n\nRead a single counter value.\n\n\n\n\n\n","category":"function"},{"location":"api/#DAQmx.write_scalar","page":"API","title":"DAQmx.write_scalar","text":"write_scalar(task::AOTask, value::Float64; auto_start::Bool=true, timeout::Float64=10.0)\n\nWrite a single voltage value to an analog output task.\n\n\n\n\n\nwrite_scalar(task::DOTask, value::UInt32; auto_start::Bool=true, timeout::Float64=10.0)\n\nWrite a single digital value to a digital output task.\n\n\n\n\n\n","category":"function"},{"location":"api/#DAQmx.available_samples","page":"API","title":"DAQmx.available_samples","text":"available_samples(task::Task) -> Int\n\nGet the number of samples available to read.\n\n\n\n\n\n","category":"function"},{"location":"api/#DAQmx.space_available","page":"API","title":"DAQmx.space_available","text":"space_available(task::Task) -> Int\n\nGet the amount of space available in the output buffer.\n\n\n\n\n\n","category":"function"},{"location":"api/#DAQmx.total_samples_acquired","page":"API","title":"DAQmx.total_samples_acquired","text":"total_samples_acquired(task::Task) -> Int\n\nGet the total number of samples acquired per channel.\n\n\n\n\n\n","category":"function"},{"location":"api/#DAQmx.total_samples_generated","page":"API","title":"DAQmx.total_samples_generated","text":"total_samples_generated(task::Task) -> Int\n\nGet the total number of samples generated per channel.\n\n\n\n\n\n","category":"function"},{"location":"api/#DAQmx.configure_timing!","page":"API","title":"DAQmx.configure_timing!","text":"configure_timing!(task::Task;\n                  source::String=\"\",\n                  rate::Float64=1000.0,\n                  active_edge::Edge=Rising,\n                  sample_mode::SampleMode=FiniteSamples,\n                  samples_per_channel::Int=1000)\n\nConfigure sample clock timing for a task.\n\nArguments\n\ntask::Task: The task to configure.\n\nKeyword Arguments\n\nsource::String: Source terminal for the sample clock (default: \"\" for internal clock).\nrate::Float64: Sample rate in samples per second (default: 1000.0).\nactive_edge::Edge: Edge to use for sampling (Rising or Falling).\nsample_mode::SampleMode: Sampling mode:\nFiniteSamples: Acquire a finite number of samples.\nContinuousSamples: Acquire continuously until stopped.\nHardwareTimedSinglePoint: Hardware-timed single point.\nsamples_per_channel::Int: Number of samples per channel to acquire/generate.\n\nExample\n\ntask = AITask(\"Dev1/ai0\")\nconfigure_timing!(task; rate=10000.0, samples_per_channel=1000, sample_mode=FiniteSamples)\n\n\n\n\n\n","category":"function"},{"location":"api/#DAQmx.configure_implicit_timing!","page":"API","title":"DAQmx.configure_implicit_timing!","text":"configure_implicit_timing!(task::Task;\n                           sample_mode::SampleMode=FiniteSamples,\n                           samples_per_channel::Int=1000)\n\nConfigure implicit timing for tasks that don't use a sample clock. This is typically used for counter output tasks.\n\nExample\n\ntask = COTask(\"Dev1/ctr0\"; freq=1000.0, duty_cycle=0.5)\nconfigure_implicit_timing!(task; sample_mode=ContinuousSamples, samples_per_channel=1000)\nstart!(task)\n\n\n\n\n\n","category":"function"},{"location":"api/#DAQmx.configure_change_detection_timing!","page":"API","title":"DAQmx.configure_change_detection_timing!","text":"configure_change_detection_timing!(task::DITask;\n                                   rising_edge_channels::String=\"\",\n                                   falling_edge_channels::String=\"\",\n                                   sample_mode::SampleMode=FiniteSamples,\n                                   samples_per_channel::Int=1000)\n\nConfigure change detection timing for digital input tasks. The task will generate a sample when a change is detected on the specified channels.\n\nKeyword Arguments\n\nrising_edge_channels::String: Channels to detect rising edges on.\nfalling_edge_channels::String: Channels to detect falling edges on.\n\n\n\n\n\n","category":"function"},{"location":"api/#DAQmx.configure_handshaking_timing!","page":"API","title":"DAQmx.configure_handshaking_timing!","text":"configure_handshaking_timing!(task::Task;\n                              sample_mode::SampleMode=FiniteSamples,\n                              samples_per_channel::Int=1000)\n\nConfigure handshaking timing for a task.\n\n\n\n\n\n","category":"function"},{"location":"api/#DAQmx.sample_rate","page":"API","title":"DAQmx.sample_rate","text":"sample_rate(task::Task) -> Float64\n\nGet the sample clock rate for a task.\n\n\n\n\n\n","category":"function"},{"location":"api/#DAQmx.set_sample_rate!","page":"API","title":"DAQmx.set_sample_rate!","text":"set_sample_rate!(task::Task, rate::Float64)\n\nSet the sample clock rate for a task.\n\n\n\n\n\n","category":"function"},{"location":"api/#DAQmx.sample_clock_source","page":"API","title":"DAQmx.sample_clock_source","text":"sample_clock_source(task::Task) -> String\n\nGet the sample clock source terminal.\n\n\n\n\n\n","category":"function"},{"location":"api/#DAQmx.set_sample_clock_source!","page":"API","title":"DAQmx.set_sample_clock_source!","text":"set_sample_clock_source!(task::Task, source::String)\n\nSet the sample clock source terminal.\n\n\n\n\n\n","category":"function"},{"location":"api/#DAQmx.samples_per_channel","page":"API","title":"DAQmx.samples_per_channel","text":"samples_per_channel(task::Task) -> Int\n\nGet the number of samples per channel for the task.\n\n\n\n\n\n","category":"function"},{"location":"api/#DAQmx.set_samples_per_channel!","page":"API","title":"DAQmx.set_samples_per_channel!","text":"set_samples_per_channel!(task::Task, count::Int)\n\nSet the number of samples per channel for the task.\n\n\n\n\n\n","category":"function"},{"location":"api/#DAQmx.configure_input_buffer!","page":"API","title":"DAQmx.configure_input_buffer!","text":"configure_input_buffer!(task::Task, samples_per_channel::Int)\n\nConfigure the size of the input buffer.\n\n\n\n\n\n","category":"function"},{"location":"api/#DAQmx.configure_output_buffer!","page":"API","title":"DAQmx.configure_output_buffer!","text":"configure_output_buffer!(task::Task, samples_per_channel::Int)\n\nConfigure the size of the output buffer.\n\n\n\n\n\n","category":"function"},{"location":"api/#DAQmx.input_buffer_size","page":"API","title":"DAQmx.input_buffer_size","text":"input_buffer_size(task::Task) -> Int\n\nGet the input buffer size per channel.\n\n\n\n\n\n","category":"function"},{"location":"api/#DAQmx.set_input_buffer_size!","page":"API","title":"DAQmx.set_input_buffer_size!","text":"set_input_buffer_size!(task::Task, size::Int)\n\nSet the input buffer size per channel.\n\n\n\n\n\n","category":"function"},{"location":"api/#DAQmx.output_buffer_size","page":"API","title":"DAQmx.output_buffer_size","text":"output_buffer_size(task::Task) -> Int\n\nGet the output buffer size per channel.\n\n\n\n\n\n","category":"function"},{"location":"api/#DAQmx.set_output_buffer_size!","page":"API","title":"DAQmx.set_output_buffer_size!","text":"set_output_buffer_size!(task::Task, size::Int)\n\nSet the output buffer size per channel.\n\n\n\n\n\n","category":"function"},{"location":"api/#DAQmx.configure_digital_start_trigger!","page":"API","title":"DAQmx.configure_digital_start_trigger!","text":"configure_digital_start_trigger!(task::Task, source::String;\n                                 edge::Edge=Rising)\n\nConfigure a digital edge start trigger for the task.\n\nArguments\n\ntask::Task: The task to configure.\nsource::String: Trigger source terminal (e.g., \"/Dev1/PFI0\").\nedge::Edge: Edge to trigger on (Rising or Falling).\n\nExample\n\ntask = AITask(\"Dev1/ai0\")\nconfigure_timing!(task; rate=10000.0, samples_per_channel=1000)\nconfigure_digital_start_trigger!(task, \"/Dev1/PFI0\"; edge=Rising)\nstart!(task)  # Task will wait for trigger\n\n\n\n\n\n","category":"function"},{"location":"api/#DAQmx.configure_analog_start_trigger!","page":"API","title":"DAQmx.configure_analog_start_trigger!","text":"configure_analog_start_trigger!(task::Task, source::String;\n                                slope::Slope=RisingSlope,\n                                level::Float64=0.0)\n\nConfigure an analog edge start trigger for the task.\n\nArguments\n\ntask::Task: The task to configure.\nsource::String: Trigger source channel (e.g., \"Dev1/ai0\").\nslope::Slope: Trigger slope (RisingSlope or FallingSlope).\nlevel::Float64: Trigger level in volts.\n\n\n\n\n\n","category":"function"},{"location":"api/#DAQmx.configure_analog_window_start_trigger!","page":"API","title":"DAQmx.configure_analog_window_start_trigger!","text":"configure_analog_window_start_trigger!(task::Task, source::String;\n                                       when::Symbol=:EnteringWindow,\n                                       window_top::Float64=1.0,\n                                       window_bottom::Float64=-1.0)\n\nConfigure an analog window start trigger for the task.\n\nKeyword Arguments\n\nwhen::Symbol: When to trigger (:EnteringWindow or :LeavingWindow).\nwindow_top::Float64: Top of the trigger window.\nwindow_bottom::Float64: Bottom of the trigger window.\n\n\n\n\n\n","category":"function"},{"location":"api/#DAQmx.disable_start_trigger!","page":"API","title":"DAQmx.disable_start_trigger!","text":"disable_start_trigger!(task::Task)\n\nDisable the start trigger for a task.\n\n\n\n\n\n","category":"function"},{"location":"api/#DAQmx.configure_digital_ref_trigger!","page":"API","title":"DAQmx.configure_digital_ref_trigger!","text":"configure_digital_ref_trigger!(task::Task, source::String;\n                               edge::Edge=Rising,\n                               pretrigger_samples::Int=100)\n\nConfigure a digital edge reference trigger.\n\nArguments\n\nsource::String: Trigger source terminal.\nedge::Edge: Edge to trigger on.\npretrigger_samples::Int: Number of samples to acquire before the trigger.\n\n\n\n\n\n","category":"function"},{"location":"api/#DAQmx.configure_analog_ref_trigger!","page":"API","title":"DAQmx.configure_analog_ref_trigger!","text":"configure_analog_ref_trigger!(task::Task, source::String;\n                              slope::Slope=RisingSlope,\n                              level::Float64=0.0,\n                              pretrigger_samples::Int=100)\n\nConfigure an analog edge reference trigger.\n\n\n\n\n\n","category":"function"},{"location":"api/#DAQmx.disable_ref_trigger!","page":"API","title":"DAQmx.disable_ref_trigger!","text":"disable_ref_trigger!(task::Task)\n\nDisable the reference trigger for a task.\n\n\n\n\n\n","category":"function"},{"location":"api/#DAQmx.PropertyDef","page":"API","title":"DAQmx.PropertyDef","text":"PropertyDef\n\nDefines metadata for an NI-DAQmx property including getter/setter functions and type.\n\n\n\n\n\n","category":"type"},{"location":"api/#DAQmx.channel_type","page":"API","title":"DAQmx.channel_type","text":"channel_type(task::Task, channel::String) -> Symbol\n\nGet the type of a channel (:AI, :AO, :DI, :DO, :CI, :CO).\n\n\n\n\n\n","category":"function"},{"location":"api/#DAQmx.measurement_type","page":"API","title":"DAQmx.measurement_type","text":"measurement_type(task::Task, channel::String) -> Int32\n\nGet the measurement or output type for a channel. Returns the NI-DAQmx constant value.\n\n\n\n\n\n","category":"function"},{"location":"api/#DAQmx.get_channel_property","page":"API","title":"DAQmx.get_channel_property","text":"get_channel_property(task::Task, channel::String, property::Symbol)\n\nGet a property value for a specific channel.\n\nExample\n\ntask = AITask(\"Dev1/ai0\")\nmax_val = get_channel_property(task, \"Dev1/ai0\", :ai_max)\n\n\n\n\n\n","category":"function"},{"location":"api/#DAQmx.set_channel_property!","page":"API","title":"DAQmx.set_channel_property!","text":"set_channel_property!(task::Task, channel::String, property::Symbol, value)\n\nSet a property value for a specific channel.\n\nExample\n\ntask = AITask(\"Dev1/ai0\")\nset_channel_property!(task, \"Dev1/ai0\", :ai_max, 5.0)\n\n\n\n\n\n","category":"function"},{"location":"api/#DAQmx.get_task_property","page":"API","title":"DAQmx.get_task_property","text":"get_task_property(task::Task, property::Symbol)\n\nGet a property value for a task.\n\n\n\n\n\n","category":"function"},{"location":"api/#DAQmx.set_task_property!","page":"API","title":"DAQmx.set_task_property!","text":"set_task_property!(task::Task, property::Symbol, value)\n\nSet a property value for a task.\n\n\n\n\n\n","category":"function"},{"location":"api/#DAQmx.list_channel_properties","page":"API","title":"DAQmx.list_channel_properties","text":"list_channel_properties() -> Vector{Symbol}\n\nList all available channel properties.\n\n\n\n\n\n","category":"function"},{"location":"api/#DAQmx.list_task_properties","page":"API","title":"DAQmx.list_task_properties","text":"list_task_properties() -> Vector{Symbol}\n\nList all available task properties.\n\n\n\n\n\n","category":"function"},{"location":"api/#DAQmx.property_info","page":"API","title":"DAQmx.property_info","text":"property_info(property::Symbol) -> PropertyDef\n\nGet information about a property.\n\n\n\n\n\n","category":"function"},{"location":"api/#DAQmx.get_all_channel_properties","page":"API","title":"DAQmx.get_all_channel_properties","text":"get_all_channel_properties(task::Task, channel::String) -> Dict{Symbol, Any}\n\nGet all readable properties for a channel.\n\n\n\n\n\n","category":"function"},{"location":"api/#DAQmx.DAQmxVersion","page":"API","title":"DAQmx.DAQmxVersion","text":"DAQmxVersion\n\nHolds the version information for the NI-DAQmx driver.\n\n\n\n\n\n","category":"type"},{"location":"api/#DAQmx.library_version","page":"API","title":"DAQmx.library_version","text":"library_version() -> DAQmxVersion\n\nQuery the installed NI-DAQmx driver version.\n\nReturns\n\nDAQmxVersion: The version of the installed NI-DAQmx driver.\n\nThrows\n\nNIDAQError: If the version cannot be determined.\n\nExample\n\njulia> v = library_version()\nNI-DAQmx v23.5.0\n\njulia> VersionNumber(v)\nv\"23.5.0\"\n\n\n\n\n\n","category":"function"},{"location":"api/#DAQmx.cached_library_version","page":"API","title":"DAQmx.cached_library_version","text":"cached_library_version() -> Union{Nothing, DAQmxVersion}\n\nGet the cached library version. Returns nothing if the library is not available. This is populated at module load time.\n\n\n\n\n\n","category":"function"},{"location":"api/#DAQmx.is_library_available","page":"API","title":"DAQmx.is_library_available","text":"is_library_available() -> Bool\n\nCheck if the NI-DAQmx library is available on the system.\n\nReturns\n\ntrue if the library can be loaded, false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"api/#DAQmx.DAQmxError","page":"API","title":"DAQmx.DAQmxError","text":"DAQmxError <: Exception\n\nException thrown when a NI-DAQmx function returns a negative error code.\n\nFields\n\ncode::Int32: The NI-DAQmx error code (negative value).\nmessage::String: The human-readable error message from NI-DAQmx.\n\n\n\n\n\n","category":"type"},{"location":"api/#DAQmx.DAQmxWarning","page":"API","title":"DAQmx.DAQmxWarning","text":"DAQmxWarning\n\nRepresents a warning from NI-DAQmx (positive return code). Warnings are logged but do not throw exceptions.\n\nFields\n\ncode::Int32: The NI-DAQmx warning code (positive value).\nmessage::String: The human-readable warning message from NI-DAQmx.\n\n\n\n\n\n","category":"type"},{"location":"api/#DAQmx.check_error","page":"API","title":"DAQmx.check_error","text":"check_error(code::Int32)\n\nCheck an NI-DAQmx return code and handle errors/warnings appropriately.\n\nIf code == 0: Success, returns nothing.\nIf code > 0: Warning, logs a warning message and returns nothing.\nIf code < 0: Error, throws a DAQmxError exception.\n\nArguments\n\ncode::Int32: The return code from an NI-DAQmx function.\n\nThrows\n\nDAQmxError: If code < 0.\n\n\n\n\n\n","category":"function"},{"location":"api/#DAQmx.get_error_message","page":"API","title":"DAQmx.get_error_message","text":"get_error_message(code::Int32) -> String\n\nRetrieve the error message string for a given NI-DAQmx error or warning code.\n\n\n\n\n\n","category":"function"},{"location":"api/#DAQmx.get_extended_error_info","page":"API","title":"DAQmx.get_extended_error_info","text":"get_extended_error_info() -> String\n\nRetrieve extended error information for the last error that occurred. This provides more detailed context than get_error_message.\n\n\n\n\n\n","category":"function"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/#Device-Discovery","page":"Examples","title":"Device Discovery","text":"List available devices and query their capabilities:\n\nusing DAQmx\n\n# Get all devices\ndevs = devices()\nfor dev in devs\n    println(\"Device: $(dev.name)\")\n    println(\"  Product: $(product_type(dev))\")\n    println(\"  Serial: $(serial_number(dev))\")\n    println(\"  AI Channels: $(ai_channels(dev))\")\n    println(\"  AO Channels: $(ao_channels(dev))\")\n    println(\"  Voltage Ranges: $(ai_voltage_ranges(dev))\")\nend","category":"section"},{"location":"examples/#Analog-Input","page":"Examples","title":"Analog Input","text":"","category":"section"},{"location":"examples/#Single-Channel-Finite-Acquisition","page":"Examples","title":"Single Channel Finite Acquisition","text":"using DAQmx\n\n# Create task with convenience constructor\ntask = AITask(\"Dev1/ai0\"; terminal_config=RSE)\n\n# Configure timing\nconfigure_timing!(task;\n    rate=10000.0,\n    samples_per_channel=1000,\n    sample_mode=FiniteSamples\n)\n\n# Acquire data\nstart!(task)\nwait_until_done(task)\ndata = read(task)\nstop!(task)\n\n# data is a Vector{Float64} with 1000 samples","category":"section"},{"location":"examples/#Multi-Channel-Acquisition","page":"Examples","title":"Multi-Channel Acquisition","text":"using DAQmx\n\n# Create empty task and add channels\ntask = AITask()\nadd_ai_voltage!(task, \"Dev1/ai0\"; terminal_config=Differential, min_val=-5.0, max_val=5.0)\nadd_ai_voltage!(task, \"Dev1/ai1\"; terminal_config=Differential, min_val=-5.0, max_val=5.0)\nadd_ai_voltage!(task, \"Dev1/ai2\"; terminal_config=Differential, min_val=-5.0, max_val=5.0)\n\nconfigure_timing!(task; rate=1000.0, samples_per_channel=100)\nstart!(task)\ndata = read(task)  # 100x3 Matrix{Float64}\nstop!(task)","category":"section"},{"location":"examples/#Continuous-Acquisition","page":"Examples","title":"Continuous Acquisition","text":"using DAQmx\n\ntask = AITask(\"Dev1/ai0\")\nconfigure_timing!(task;\n    rate=10000.0,\n    sample_mode=ContinuousSamples,\n    samples_per_channel=10000\n)\n\nstart!(task)\n\n# Read in chunks\nfor i in 1:10\n    n_available = available_samples(task)\n    if n_available >= 1000\n        data = read(task; samples_per_channel=1000)\n        println(\"Read $(length(data)) samples, total acquired: $(total_samples_acquired(task))\")\n    end\n    sleep(0.1)\nend\n\nstop!(task)","category":"section"},{"location":"examples/#Thermocouple-Measurement","page":"Examples","title":"Thermocouple Measurement","text":"using DAQmx\n\ntask = AITask()\nadd_ai_thermocouple!(task, \"Dev1/ai0\";\n    min_val=0.0,\n    max_val=200.0,\n    units=:DegC,\n    thermocouple_type=:K_Type,\n    cjc_source=:BuiltIn\n)\n\nstart!(task)\ntemp = read_scalar(task)\nprintln(\"Temperature: $temp C\")\nstop!(task)","category":"section"},{"location":"examples/#Analog-Output","page":"Examples","title":"Analog Output","text":"","category":"section"},{"location":"examples/#Single-Point-Output","page":"Examples","title":"Single Point Output","text":"using DAQmx\n\ntask = AOTask(\"Dev1/ao0\"; min_val=0.0, max_val=5.0)\nwrite_scalar(task, 2.5)  # Output 2.5V","category":"section"},{"location":"examples/#Waveform-Output","page":"Examples","title":"Waveform Output","text":"using DAQmx\n\ntask = AOTask(\"Dev1/ao0\")\nconfigure_timing!(task;\n    rate=10000.0,\n    samples_per_channel=10000,\n    sample_mode=FiniteSamples\n)\n\n# Generate sine wave: 100 Hz, 5V amplitude\nt = range(0, 1, length=10000)\nwaveform = 5.0 .* sin.(2Ï€ .* 100 .* t)\n\nwrite(task, waveform; auto_start=false)\nstart!(task)\nwait_until_done(task)\nstop!(task)","category":"section"},{"location":"examples/#Continuous-Waveform-Generation","page":"Examples","title":"Continuous Waveform Generation","text":"using DAQmx\n\ntask = AOTask(\"Dev1/ao0\")\nconfigure_timing!(task;\n    rate=100000.0,\n    sample_mode=ContinuousSamples,\n    samples_per_channel=100000\n)\n\n# Pre-fill buffer\nt = range(0, 1, length=100000)\nwaveform = 5.0 .* sin.(2Ï€ .* 1000 .* t)\n\nwrite(task, waveform; auto_start=false)\nstart!(task)\n\n# Task generates continuously until stopped\nsleep(5.0)\nstop!(task)","category":"section"},{"location":"examples/#Digital-I/O","page":"Examples","title":"Digital I/O","text":"","category":"section"},{"location":"examples/#Reading-Digital-Lines","page":"Examples","title":"Reading Digital Lines","text":"using DAQmx\n\n# Read 8 digital lines as a byte\ntask = DITask(\"Dev1/port0/line0:7\"; line_grouping=ChannelForAllLines)\ndata = read(task, UInt8)\nprintln(\"Port value: 0x$(string(data[1], base=16))\")","category":"section"},{"location":"examples/#Writing-Digital-Lines","page":"Examples","title":"Writing Digital Lines","text":"using DAQmx\n\ntask = DOTask(\"Dev1/port0/line0:7\"; line_grouping=ChannelForAllLines)\nwrite(task, UInt8[0xFF])  # All lines high\nsleep(1.0)\nwrite(task, UInt8[0x00])  # All lines low","category":"section"},{"location":"examples/#Change-Detection","page":"Examples","title":"Change Detection","text":"using DAQmx\n\ntask = DITask(\"Dev1/port0/line0:3\")\nconfigure_change_detection_timing!(task;\n    rising_edge_channels=\"Dev1/port0/line0:3\",\n    falling_edge_channels=\"Dev1/port0/line0:3\",\n    sample_mode=FiniteSamples,\n    samples_per_channel=100\n)\n\nstart!(task)\n# Task generates samples when lines change state\ndata = read(task; samples_per_channel=100, timeout=30.0)\nstop!(task)","category":"section"},{"location":"examples/#Counter-Input","page":"Examples","title":"Counter Input","text":"","category":"section"},{"location":"examples/#Edge-Counting","page":"Examples","title":"Edge Counting","text":"using DAQmx\n\ntask = CITask(\"Dev1/ctr0\"; method=:count_edges, edge=Rising, count_direction=CountUp)\nconfigure_implicit_timing!(task; sample_mode=ContinuousSamples)\n\nstart!(task)\nsleep(1.0)\ncount = read_scalar(task)\nprintln(\"Edges counted: $count\")\nstop!(task)","category":"section"},{"location":"examples/#Frequency-Measurement","page":"Examples","title":"Frequency Measurement","text":"using DAQmx\n\ntask = CITask(\"Dev1/ctr0\";\n    method=:freq,\n    min_val=1.0,\n    max_val=1000000.0,\n    meas_method=:LowFreq1Ctr\n)\n\nconfigure_implicit_timing!(task; sample_mode=FiniteSamples, samples_per_channel=10)\nstart!(task)\nfreqs = read(task, Float64; samples_per_channel=10)\nprintln(\"Measured frequencies: $freqs Hz\")\nstop!(task)","category":"section"},{"location":"examples/#Angular-Encoder","page":"Examples","title":"Angular Encoder","text":"using DAQmx\n\ntask = CITask(\"Dev1/ctr0\";\n    method=:ang_encoder,\n    decoding_type=EncoderX4,\n    pulses_per_rev=UInt32(1024),\n    z_idx_enable=true,\n    z_idx_phase=AHighBHigh,\n    units=:Degrees\n)\n\nconfigure_implicit_timing!(task; sample_mode=ContinuousSamples)\nstart!(task)\n\nfor _ in 1:10\n    angle = read_scalar(task)\n    println(\"Angle: $angle degrees\")\n    sleep(0.1)\nend\n\nstop!(task)","category":"section"},{"location":"examples/#Counter-Output","page":"Examples","title":"Counter Output","text":"","category":"section"},{"location":"examples/#Pulse-Generation","page":"Examples","title":"Pulse Generation","text":"using DAQmx\n\n# 1 kHz square wave, 50% duty cycle\ntask = COTask(\"Dev1/ctr0\"; method=:pulse_freq, freq=1000.0, duty_cycle=0.5)\nconfigure_implicit_timing!(task; sample_mode=ContinuousSamples)\n\nstart!(task)\nsleep(5.0)  # Generate for 5 seconds\nstop!(task)","category":"section"},{"location":"examples/#Finite-Pulse-Train","page":"Examples","title":"Finite Pulse Train","text":"using DAQmx\n\ntask = COTask(\"Dev1/ctr0\"; method=:pulse_freq, freq=100.0, duty_cycle=0.5)\nconfigure_implicit_timing!(task; sample_mode=FiniteSamples, samples_per_channel=10)\n\nstart!(task)\nwait_until_done(task)  # Wait for 10 pulses\nstop!(task)","category":"section"},{"location":"examples/#Triggering","page":"Examples","title":"Triggering","text":"","category":"section"},{"location":"examples/#Digital-Start-Trigger","page":"Examples","title":"Digital Start Trigger","text":"using DAQmx\n\ntask = AITask(\"Dev1/ai0\")\nconfigure_timing!(task; rate=10000.0, samples_per_channel=1000)\nconfigure_digital_start_trigger!(task, \"/Dev1/PFI0\"; edge=Rising)\n\nstart!(task)  # Task waits for trigger\nprintln(\"Waiting for trigger on PFI0...\")\nwait_until_done(task; timeout=30.0)\ndata = read(task)\nstop!(task)","category":"section"},{"location":"examples/#Analog-Start-Trigger","page":"Examples","title":"Analog Start Trigger","text":"using DAQmx\n\ntask = AITask(\"Dev1/ai0:1\")\nconfigure_timing!(task; rate=10000.0, samples_per_channel=1000)\n\n# Trigger when ai0 crosses 1.0V rising\nconfigure_analog_start_trigger!(task, \"Dev1/ai0\"; slope=RisingSlope, level=1.0)\n\nstart!(task)\nwait_until_done(task; timeout=30.0)\ndata = read(task)\nstop!(task)","category":"section"},{"location":"examples/#Reference-Trigger-(Pre/Post-Trigger)","page":"Examples","title":"Reference Trigger (Pre/Post Trigger)","text":"using DAQmx\n\ntask = AITask(\"Dev1/ai0\")\nconfigure_timing!(task; rate=10000.0, samples_per_channel=1000)\n\n# Capture 100 samples before and 900 after trigger\nconfigure_digital_ref_trigger!(task, \"/Dev1/PFI0\";\n    edge=Rising,\n    pretrigger_samples=100\n)\n\nstart!(task)\nwait_until_done(task)\ndata = read(task)  # Contains pre and post trigger data\nstop!(task)","category":"section"},{"location":"examples/#Synchronized-Tasks","page":"Examples","title":"Synchronized Tasks","text":"","category":"section"},{"location":"examples/#Multi-Task-Synchronization","page":"Examples","title":"Multi-Task Synchronization","text":"using DAQmx\n\n# Create AI and AO tasks\nai_task = AITask(\"Dev1/ai0\")\nao_task = AOTask(\"Dev1/ao0\")\n\n# Configure both with same timing\nconfigure_timing!(ai_task; rate=10000.0, samples_per_channel=1000, source=\"/Dev1/ao/SampleClock\")\nconfigure_timing!(ao_task; rate=10000.0, samples_per_channel=1000)\n\n# Generate waveform\nwaveform = sin.(2Ï€ .* (0:999) ./ 1000)\nwrite(ao_task, waveform; auto_start=false)\n\n# Start both (AI first since it's slave)\nstart!(ai_task)\nstart!(ao_task)\n\nwait_until_done(ao_task)\ndata = read(ai_task)\n\nstop!(ai_task)\nstop!(ao_task)","category":"section"},{"location":"#DAQmx.jl","page":"Home","title":"DAQmx.jl","text":"A Julia wrapper for National Instruments NI-DAQmx driver, providing type-safe access to NI data acquisition hardware.","category":"section"},{"location":"#Features","page":"Home","title":"Features","text":"Parametric task types (AITask, AOTask, DITask, DOTask, CITask, COTask) for type-safe dispatch\nJulia enums for terminal configuration, edge detection, sample modes\nAutomatic task handle cleanup via finalizers\nSupport for analog, digital, and counter I/O\nTiming configuration: sample clock, implicit, change detection\nTrigger support: digital edge, analog edge, analog window","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"using Pkg\nPkg.add(url=\"https://github.com/LidkeLab/DAQmx.jl\")\n\nRequires NI-DAQmx driver to be installed on your system.","category":"section"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"using DAQmx\n\n# List available devices\ndevs = devices()\n\n# Analog input: read 100 samples at 1 kHz\ntask = AITask(\"Dev1/ai0\")\nconfigure_timing!(task; rate=1000.0, samples_per_channel=100)\nstart!(task)\ndata = read(task)\nstop!(task)\n\n# Analog output: write a sine wave\ntask = AOTask(\"Dev1/ao0\")\nwrite(task, sin.(2Ï€ .* (0:99) ./ 100))","category":"section"},{"location":"#Task-Types","page":"Home","title":"Task Types","text":"DAQmx.jl uses parametric types to enable type-safe dispatch:\n\nType Alias Task Kind Use\nAITask Task{AnalogInputKind} Analog voltage/current/temperature input\nAOTask Task{AnalogOutputKind} Analog voltage/current output\nDITask Task{DigitalInputKind} Digital line/port input\nDOTask Task{DigitalOutputKind} Digital line/port output\nCITask Task{CounterInputKind} Edge counting, frequency, period, encoders\nCOTask Task{CounterOutputKind} Pulse generation","category":"section"},{"location":"#Documentation","page":"Home","title":"Documentation","text":"Examples - Detailed usage examples\nAPI Reference - Complete API documentation","category":"section"}]
}
