var documenterSearchIndex = {"docs":
[{"location":"#NIDAQmx","page":"Home","title":"NIDAQmx","text":"Documentation for NIDAQmx.\n\n","category":"section"},{"location":"#NIDAQmx.NIDAQmx","page":"Home","title":"NIDAQmx.NIDAQmx","text":"NIDAQmx\n\nA Julia wrapper for National Instruments NI-DAQmx driver.\n\nThis package provides a clean, type-safe interface to NI data acquisition hardware. It uses parametric types for task types and explicit error handling.\n\nBasic Usage\n\nusing NIDAQmx\n\n# List available devices\ndevs = devices()\n\n# Analog Input\ntask = AITask(\"Dev1/ai0\")\nconfigure_timing!(task; rate=1000.0, samples_per_channel=100)\nstart!(task)\ndata = read(task)\nstop!(task)\n\n# Analog Output\ntask = AOTask(\"Dev1/ao0\")\nwrite(task, sin.(2π .* (0:99) ./ 100))\n\n# Digital I/O\ntask = DITask(\"Dev1/port0/line0:7\")\ndata = read(task)\n\n# Counter Input\ntask = CITask(\"Dev1/ctr0\"; method=:count_edges)\nconfigure_implicit_timing!(task; sample_mode=ContinuousSamples)\nstart!(task)\ncounts = read(task)\n\nSee the documentation for more detailed usage examples.\n\n\n\n\n\n","category":"module"},{"location":"#NIDAQmx.CHANNEL_PROPERTIES","page":"Home","title":"NIDAQmx.CHANNEL_PROPERTIES","text":"CHANNEL_PROPERTIES\n\nDictionary mapping property symbols to their metadata for channel properties.\n\n\n\n\n\n","category":"constant"},{"location":"#NIDAQmx.TASK_PROPERTIES","page":"Home","title":"NIDAQmx.TASK_PROPERTIES","text":"TASK_PROPERTIES\n\nDictionary mapping property symbols to their metadata for task properties.\n\n\n\n\n\n","category":"constant"},{"location":"#NIDAQmx.libnidaq","page":"Home","title":"NIDAQmx.libnidaq","text":"libnidaq\n\nThe path to the NIDAQmx shared library. Automatically detected based on the operating system.\n\n\n\n\n\n","category":"constant"},{"location":"#NIDAQmx.AITask-Tuple{String}","page":"Home","title":"NIDAQmx.AITask","text":"AITask(channel::String; kwargs...) -> AITask\n\nCreate an analog input task with a single voltage channel.\n\nExample\n\ntask = AITask(\"Dev1/ai0\"; terminal_config=RSE)\n\n\n\n\n\n","category":"method"},{"location":"#NIDAQmx.AOTask-Tuple{String}","page":"Home","title":"NIDAQmx.AOTask","text":"AOTask(channel::String; kwargs...) -> AOTask\n\nCreate an analog output task with a single voltage channel.\n\nExample\n\ntask = AOTask(\"Dev1/ao0\"; min_val=0.0, max_val=5.0)\n\n\n\n\n\n","category":"method"},{"location":"#NIDAQmx.AbstractChannel","page":"Home","title":"NIDAQmx.AbstractChannel","text":"AbstractChannel\n\nAbstract supertype for all channel types.\n\n\n\n\n\n","category":"type"},{"location":"#NIDAQmx.AnalogChannel","page":"Home","title":"NIDAQmx.AnalogChannel","text":"AnalogChannel <: AbstractChannel\n\nRepresents an analog channel (input or output).\n\nFields\n\nphysical_channel::String: The physical channel name (e.g., \"Dev1/ai0\").\nname::String: The assigned name for the channel.\n\n\n\n\n\n","category":"type"},{"location":"#NIDAQmx.CITask-Tuple{String}","page":"Home","title":"NIDAQmx.CITask","text":"CITask(counter::String; method::Symbol=:count_edges, kwargs...) -> CITask\n\nCreate a counter input task.\n\nArguments\n\ncounter::String: Counter name.\nmethod::Symbol: Measurement method (:count_edges, :freq, :period, etc.).\n\n\n\n\n\n","category":"method"},{"location":"#NIDAQmx.COTask-Tuple{String}","page":"Home","title":"NIDAQmx.COTask","text":"COTask(counter::String; method::Symbol=:pulse_freq, kwargs...) -> COTask\n\nCreate a counter output task.\n\nArguments\n\ncounter::String: Counter name.\nmethod::Symbol: Output method (:pulse_freq, :pulse_time, :pulse_ticks).\n\n\n\n\n\n","category":"method"},{"location":"#NIDAQmx.CountDirection","page":"Home","title":"NIDAQmx.CountDirection","text":"CountDirection\n\nDirection for counter channels.\n\n\n\n\n\n","category":"type"},{"location":"#NIDAQmx.CounterChannel","page":"Home","title":"NIDAQmx.CounterChannel","text":"CounterChannel <: AbstractChannel\n\nRepresents a counter channel (input or output).\n\nFields\n\ncounter::String: The counter name (e.g., \"Dev1/ctr0\").\nname::String: The assigned name for the channel.\n\n\n\n\n\n","category":"type"},{"location":"#NIDAQmx.Coupling","page":"Home","title":"NIDAQmx.Coupling","text":"Coupling\n\nInput coupling mode.\n\n\n\n\n\n","category":"type"},{"location":"#NIDAQmx.DITask-Tuple{String}","page":"Home","title":"NIDAQmx.DITask","text":"DITask(lines::String; kwargs...) -> DITask\n\nCreate a digital input task with the specified lines.\n\nExample\n\ntask = DITask(\"Dev1/port0/line0:7\")\n\n\n\n\n\n","category":"method"},{"location":"#NIDAQmx.DOTask-Tuple{String}","page":"Home","title":"NIDAQmx.DOTask","text":"DOTask(lines::String; kwargs...) -> DOTask\n\nCreate a digital output task with the specified lines.\n\nExample\n\ntask = DOTask(\"Dev1/port0/line0:7\")\n\n\n\n\n\n","category":"method"},{"location":"#NIDAQmx.Device","page":"Home","title":"NIDAQmx.Device","text":"Device\n\nRepresents a NI-DAQmx device.\n\nFields\n\nname::String: The device name (e.g., \"Dev1\").\n\n\n\n\n\n","category":"type"},{"location":"#NIDAQmx.DigitalChannel","page":"Home","title":"NIDAQmx.DigitalChannel","text":"DigitalChannel <: AbstractChannel\n\nRepresents a digital channel (input or output).\n\nFields\n\nlines::String: The digital lines (e.g., \"Dev1/port0/line0:7\").\nname::String: The assigned name for the channel.\n\n\n\n\n\n","category":"type"},{"location":"#NIDAQmx.Edge","page":"Home","title":"NIDAQmx.Edge","text":"Edge\n\nEdge type for triggers and timing.\n\n\n\n\n\n","category":"type"},{"location":"#NIDAQmx.EncoderType","page":"Home","title":"NIDAQmx.EncoderType","text":"EncoderType\n\nEncoder decoding type for angular/linear encoders.\n\n\n\n\n\n","category":"type"},{"location":"#NIDAQmx.ExcitationSource","page":"Home","title":"NIDAQmx.ExcitationSource","text":"ExcitationSource\n\nExcitation source for sensors.\n\n\n\n\n\n","category":"type"},{"location":"#NIDAQmx.FillMode","page":"Home","title":"NIDAQmx.FillMode","text":"FillMode\n\nData layout for read/write operations.\n\n\n\n\n\n","category":"type"},{"location":"#NIDAQmx.Level","page":"Home","title":"NIDAQmx.Level","text":"Level\n\nLogic level.\n\n\n\n\n\n","category":"type"},{"location":"#NIDAQmx.LineGrouping","page":"Home","title":"NIDAQmx.LineGrouping","text":"LineGrouping\n\nDigital line grouping mode.\n\n\n\n\n\n","category":"type"},{"location":"#NIDAQmx.NIDAQError","page":"Home","title":"NIDAQmx.NIDAQError","text":"NIDAQError <: Exception\n\nException thrown when a NIDAQmx function returns a negative error code.\n\nFields\n\ncode::Int32: The NIDAQmx error code (negative value).\nmessage::String: The human-readable error message from NIDAQmx.\n\n\n\n\n\n","category":"type"},{"location":"#NIDAQmx.NIDAQWarning","page":"Home","title":"NIDAQmx.NIDAQWarning","text":"NIDAQWarning\n\nRepresents a warning from NIDAQmx (positive return code). Warnings are logged but do not throw exceptions.\n\nFields\n\ncode::Int32: The NIDAQmx warning code (positive value).\nmessage::String: The human-readable warning message from NIDAQmx.\n\n\n\n\n\n","category":"type"},{"location":"#NIDAQmx.NIDAQmxVersion","page":"Home","title":"NIDAQmx.NIDAQmxVersion","text":"NIDAQmxVersion\n\nHolds the version information for the NIDAQmx driver.\n\n\n\n\n\n","category":"type"},{"location":"#NIDAQmx.PropertyDef","page":"Home","title":"NIDAQmx.PropertyDef","text":"PropertyDef\n\nDefines metadata for a NIDAQmx property including getter/setter functions and type.\n\n\n\n\n\n","category":"type"},{"location":"#NIDAQmx.ResistanceConfig","page":"Home","title":"NIDAQmx.ResistanceConfig","text":"ResistanceConfig\n\nResistance measurement configuration.\n\n\n\n\n\n","category":"type"},{"location":"#NIDAQmx.SampleMode","page":"Home","title":"NIDAQmx.SampleMode","text":"SampleMode\n\nSample acquisition mode.\n\n\n\n\n\n","category":"type"},{"location":"#NIDAQmx.SampleTimingType","page":"Home","title":"NIDAQmx.SampleTimingType","text":"SampleTimingType\n\nTiming type for sample clock.\n\n\n\n\n\n","category":"type"},{"location":"#NIDAQmx.Slope","page":"Home","title":"NIDAQmx.Slope","text":"Slope\n\nSlope for analog triggers.\n\n\n\n\n\n","category":"type"},{"location":"#NIDAQmx.Task","page":"Home","title":"NIDAQmx.Task","text":"Task{K<:TaskKind}\n\nA NIDAQmx task with parametric type for the task kind. This allows for type-safe dispatch on different task types.\n\nFields\n\nhandle::TaskHandle: The underlying NIDAQmx task handle.\nname::String: The name of the task.\n\nType Aliases\n\nAITask = Task{AnalogInputKind}\nAOTask = Task{AnalogOutputKind}\nDITask = Task{DigitalInputKind}\nDOTask = Task{DigitalOutputKind}\nCITask = Task{CounterInputKind}\nCOTask = Task{CounterOutputKind}\n\n\n\n\n\n","category":"type"},{"location":"#NIDAQmx.TaskKind","page":"Home","title":"NIDAQmx.TaskKind","text":"TaskKind\n\nAbstract supertype for task kind type parameters.\n\n\n\n\n\n","category":"type"},{"location":"#NIDAQmx.TerminalConfig","page":"Home","title":"NIDAQmx.TerminalConfig","text":"TerminalConfig\n\nTerminal configuration for analog input channels.\n\n\n\n\n\n","category":"type"},{"location":"#NIDAQmx.TriggerType","page":"Home","title":"NIDAQmx.TriggerType","text":"TriggerType\n\nTrigger type enumeration.\n\n\n\n\n\n","category":"type"},{"location":"#NIDAQmx.ZIndexPhase","page":"Home","title":"NIDAQmx.ZIndexPhase","text":"ZIndexPhase\n\nZ-index phase for encoders.\n\n\n\n\n\n","category":"type"},{"location":"#Base.read-Tuple{AITask}","page":"Home","title":"Base.read","text":"read(task::AITask; samples_per_channel::Int=-1, timeout::Float64=10.0,\n     fill_mode::FillMode=GroupByChannel) -> Matrix{Float64}\n\nRead analog data from an analog input task.\n\nArguments\n\ntask::AITask: The analog input task.\n\nKeyword Arguments\n\nsamples_per_channel::Int: Number of samples per channel to read. Use -1 to read all available samples (default: -1).\ntimeout::Float64: Timeout in seconds (default: 10.0). Use -1.0 for infinite.\nfill_mode::FillMode: Data layout (GroupByChannel or GroupByScanNumber).\n\nReturns\n\nVector{Float64} if single channel, Matrix{Float64} if multiple channels. For GroupByChannel: columns are channels, rows are samples.\n\nExample\n\ntask = AITask(\"Dev1/ai0:1\")\nconfigure_timing!(task; rate=1000.0, samples_per_channel=100)\nstart!(task)\ndata = read(task; samples_per_channel=100)  # 100×2 Matrix\nstop!(task)\n\n\n\n\n\n","category":"method"},{"location":"#Base.read-Tuple{CITask, Type{Float64}}","page":"Home","title":"Base.read","text":"read(task::CITask, ::Type{Float64}; samples_per_channel::Int=-1, timeout::Float64=10.0) -> Vector{Float64}\n\nRead counter data as floating point values.\n\n\n\n\n\n","category":"method"},{"location":"#Base.read-Tuple{CITask}","page":"Home","title":"Base.read","text":"read(task::CITask; samples_per_channel::Int=-1, timeout::Float64=10.0) -> Vector\n\nRead counter data from a counter input task.\n\n\n\n\n\n","category":"method"},{"location":"#Base.read-Tuple{DITask}","page":"Home","title":"Base.read","text":"read(task::DITask; samples_per_channel::Int=-1, timeout::Float64=10.0,\n     fill_mode::FillMode=GroupByChannel) -> Array{UInt32}\n\nRead digital data from a digital input task.\n\nReturns\n\nVector{UInt32} if single channel, Matrix{UInt32} if multiple channels.\n\n\n\n\n\n","category":"method"},{"location":"#Base.read-Union{Tuple{T}, Tuple{AITask, Type{T}}} where T<:Union{Float64, Int16, Int32, UInt16, UInt32}","page":"Home","title":"Base.read","text":"read(task::AITask, ::Type{T}; kwargs...) where T\n\nRead analog data with a specific precision type. Supported types: Float64, Int16, UInt16, Int32, UInt32.\n\n\n\n\n\n","category":"method"},{"location":"#Base.read-Union{Tuple{T}, Tuple{DITask, Type{T}}} where T<:Union{UInt16, UInt32, UInt8}","page":"Home","title":"Base.read","text":"read(task::DITask, ::Type{T}; kwargs...) where T\n\nRead digital data with a specific type. Supported: UInt8, UInt16, UInt32.\n\n\n\n\n\n","category":"method"},{"location":"#Base.write-Tuple{AOTask, AbstractVector{Float64}}","page":"Home","title":"Base.write","text":"write(task::AOTask, data::AbstractArray{Float64};\n      auto_start::Bool=true, timeout::Float64=10.0,\n      data_layout::FillMode=GroupByChannel) -> Int\n\nWrite analog data to an analog output task.\n\nArguments\n\ntask::AOTask: The analog output task.\ndata::AbstractArray{Float64}: Data to write. For multiple channels, use a matrix where rows are samples and columns are channels (with GroupByChannel).\n\nKeyword Arguments\n\nauto_start::Bool: Automatically start the task (default: true).\ntimeout::Float64: Timeout in seconds (default: 10.0).\ndata_layout::FillMode: Data layout in the array.\n\nReturns\n\nNumber of samples per channel written.\n\nExample\n\ntask = AOTask(\"Dev1/ao0\")\nconfigure_timing!(task; rate=1000.0, samples_per_channel=100)\ndata = sin.(2π .* (0:99) ./ 100) .* 5.0  # Sine wave\nwrite(task, data)\nwait_until_done(task)\n\n\n\n\n\n","category":"method"},{"location":"#Base.write-Tuple{DOTask, AbstractVector{UInt8}}","page":"Home","title":"Base.write","text":"write(task::DOTask, data::AbstractArray{T}; kwargs...) where T\n\nWrite digital data to a digital output task. Supported types: UInt8, UInt16, UInt32.\n\n\n\n\n\n","category":"method"},{"location":"#NIDAQmx.add_ai_accel!-Tuple{AITask, String}","page":"Home","title":"NIDAQmx.add_ai_accel!","text":"add_ai_accel!(task::AITask, channel::String;\n              terminal_config::TerminalConfig=Differential,\n              min_val::Float64=-5.0,\n              max_val::Float64=5.0,\n              units::Symbol=:g,\n              sensitivity::Float64=100.0,\n              sensitivity_units::Symbol=:mVoltsPerG,\n              current_excit_source::ExcitationSource=ExcitationInternal,\n              current_excit_val::Float64=0.002,\n              name::String=\"\",\n              custom_scale::String=\"\")\n\nAdd an accelerometer input channel.\n\nKeyword Arguments\n\nsensitivity::Float64: Sensor sensitivity (default: 100.0 mV/g).\nsensitivity_units::Symbol: Units for sensitivity (:mVoltsPerG, :VoltsPerG).\n\n\n\n\n\n","category":"method"},{"location":"#NIDAQmx.add_ai_current!-Tuple{AITask, String}","page":"Home","title":"NIDAQmx.add_ai_current!","text":"add_ai_current!(task::AITask, channel::String;\n                terminal_config::TerminalConfig=Differential,\n                min_val::Float64=-0.01,\n                max_val::Float64=0.01,\n                units::Symbol=:Amps,\n                shunt_resistor_loc::Symbol=:Default,\n                ext_shunt_resistor_val::Float64=249.0,\n                name::String=\"\",\n                custom_scale::String=\"\")\n\nAdd an analog input current channel to the task.\n\nArguments\n\ntask::AITask: The analog input task.\nchannel::String: Physical channel name.\n\nKeyword Arguments\n\nterminal_config::TerminalConfig: Terminal configuration (default: Differential).\nmin_val::Float64: Minimum expected current in units (default: -0.01).\nmax_val::Float64: Maximum expected current in units (default: 0.01).\nunits::Symbol: Units for the measurement (default: :Amps).\nshunt_resistor_loc::Symbol: Location of shunt resistor (:Default, :Internal, :External).\next_shunt_resistor_val::Float64: External shunt resistor value in ohms.\nname::String: Name to assign to the channel.\ncustom_scale::String: Name of custom scale.\n\n\n\n\n\n","category":"method"},{"location":"#NIDAQmx.add_ai_resistance!-Tuple{AITask, String}","page":"Home","title":"NIDAQmx.add_ai_resistance!","text":"add_ai_resistance!(task::AITask, channel::String;\n                   min_val::Float64=0.0,\n                   max_val::Float64=1000.0,\n                   units::Symbol=:Ohms,\n                   resistance_config::ResistanceConfig=TwoWire,\n                   current_excit_source::ExcitationSource=ExcitationInternal,\n                   current_excit_val::Float64=0.001,\n                   name::String=\"\",\n                   custom_scale::String=\"\")\n\nAdd a resistance measurement channel.\n\n\n\n\n\n","category":"method"},{"location":"#NIDAQmx.add_ai_rtd!-Tuple{AITask, String}","page":"Home","title":"NIDAQmx.add_ai_rtd!","text":"add_ai_rtd!(task::AITask, channel::String;\n            min_val::Float64=0.0,\n            max_val::Float64=100.0,\n            units::Symbol=:DegC,\n            rtd_type::Symbol=:Pt3851,\n            resistance_config::ResistanceConfig=FourWire,\n            current_excit_source::ExcitationSource=ExcitationInternal,\n            current_excit_val::Float64=0.001,\n            r0::Float64=100.0,\n            name::String=\"\")\n\nAdd an RTD (Resistance Temperature Detector) input channel.\n\n\n\n\n\n","category":"method"},{"location":"#NIDAQmx.add_ai_thermocouple!-Tuple{AITask, String}","page":"Home","title":"NIDAQmx.add_ai_thermocouple!","text":"add_ai_thermocouple!(task::AITask, channel::String;\n                     min_val::Float64=0.0,\n                     max_val::Float64=100.0,\n                     units::Symbol=:DegC,\n                     thermocouple_type::Symbol=:K_Type,\n                     cjc_source::Symbol=:BuiltIn,\n                     cjc_val::Float64=25.0,\n                     cjc_channel::String=\"\",\n                     name::String=\"\")\n\nAdd a thermocouple input channel to the task.\n\nKeyword Arguments\n\nunits::Symbol: Temperature units (:DegC, :DegF, :Kelvins, :DegR).\nthermocouple_type::Symbol: Type of thermocouple (:J_Type, :K_Type, :N_Type, :R_Type, :S_Type, :T_Type, :B_Type, :E_Type).\ncjc_source::Symbol: Cold junction compensation source (:BuiltIn, :ConstVal, :Chan).\ncjc_val::Float64: Cold junction temperature if cjc_source is :ConstVal.\ncjc_channel::String: CJC channel name if cjc_source is :Chan.\n\n\n\n\n\n","category":"method"},{"location":"#NIDAQmx.add_ai_voltage!-Tuple{AITask, String}","page":"Home","title":"NIDAQmx.add_ai_voltage!","text":"add_ai_voltage!(task::AITask, channel::String;\n                terminal_config::TerminalConfig=Differential,\n                min_val::Float64=-10.0,\n                max_val::Float64=10.0,\n                units::Symbol=:Volts,\n                name::String=\"\",\n                custom_scale::String=\"\")\n\nAdd an analog input voltage channel to the task.\n\nArguments\n\ntask::AITask: The analog input task.\nchannel::String: Physical channel name (e.g., \"Dev1/ai0\" or \"Dev1/ai0:3\").\n\nKeyword Arguments\n\nterminal_config::TerminalConfig: Terminal configuration (default: Differential). Options: TerminalDefault, RSE, NRSE, Differential, PseudoDifferential.\nmin_val::Float64: Minimum expected value in units (default: -10.0).\nmax_val::Float64: Maximum expected value in units (default: 10.0).\nunits::Symbol: Units for the measurement (default: :Volts). Options: :Volts, :FromCustomScale.\nname::String: Name to assign to the channel (default: \"\").\ncustom_scale::String: Name of custom scale to use if units is :FromCustomScale.\n\nExample\n\ntask = AITask()\nadd_ai_voltage!(task, \"Dev1/ai0\"; terminal_config=RSE, min_val=-5.0, max_val=5.0)\nadd_ai_voltage!(task, \"Dev1/ai1\"; terminal_config=RSE, min_val=-5.0, max_val=5.0)\n\n\n\n\n\n","category":"method"},{"location":"#NIDAQmx.add_ao_current!-Tuple{AOTask, String}","page":"Home","title":"NIDAQmx.add_ao_current!","text":"add_ao_current!(task::AOTask, channel::String;\n                min_val::Float64=0.0,\n                max_val::Float64=0.02,\n                units::Symbol=:Amps,\n                name::String=\"\",\n                custom_scale::String=\"\")\n\nAdd an analog output current channel to the task.\n\n\n\n\n\n","category":"method"},{"location":"#NIDAQmx.add_ao_funcgen!-Tuple{AOTask, String}","page":"Home","title":"NIDAQmx.add_ao_funcgen!","text":"add_ao_funcgen!(task::AOTask, channel::String;\n                type::Symbol=:Sine,\n                freq::Float64=1000.0,\n                amplitude::Float64=1.0,\n                offset::Float64=0.0,\n                name::String=\"\")\n\nAdd a function generator channel to the task.\n\nKeyword Arguments\n\ntype::Symbol: Waveform type (:Sine, :Triangle, :Square, :Sawtooth).\nfreq::Float64: Frequency in Hz.\namplitude::Float64: Peak-to-peak amplitude in volts.\noffset::Float64: DC offset in volts.\n\n\n\n\n\n","category":"method"},{"location":"#NIDAQmx.add_ao_voltage!-Tuple{AOTask, String}","page":"Home","title":"NIDAQmx.add_ao_voltage!","text":"add_ao_voltage!(task::AOTask, channel::String;\n                min_val::Float64=-10.0,\n                max_val::Float64=10.0,\n                units::Symbol=:Volts,\n                name::String=\"\",\n                custom_scale::String=\"\")\n\nAdd an analog output voltage channel to the task.\n\nArguments\n\ntask::AOTask: The analog output task.\nchannel::String: Physical channel name (e.g., \"Dev1/ao0\").\n\nKeyword Arguments\n\nmin_val::Float64: Minimum output value in units (default: -10.0).\nmax_val::Float64: Maximum output value in units (default: 10.0).\nunits::Symbol: Units for output (default: :Volts).\nname::String: Name to assign to the channel.\ncustom_scale::String: Name of custom scale if units is :FromCustomScale.\n\nExample\n\ntask = AOTask()\nadd_ao_voltage!(task, \"Dev1/ao0\"; min_val=0.0, max_val=5.0)\n\n\n\n\n\n","category":"method"},{"location":"#NIDAQmx.add_ci_ang_encoder!-Tuple{CITask, String}","page":"Home","title":"NIDAQmx.add_ci_ang_encoder!","text":"add_ci_ang_encoder!(task::CITask, counter::String;\n                    decoding_type::EncoderType=EncoderX4,\n                    z_idx_enable::Bool=true,\n                    z_idx_val::Float64=0.0,\n                    z_idx_phase::ZIndexPhase=AHighBHigh,\n                    units::Symbol=:Degrees,\n                    pulses_per_rev::UInt32=UInt32(1024),\n                    initial_angle::Float64=0.0,\n                    name::String=\"\",\n                    custom_scale::String=\"\")\n\nAdd an angular encoder input channel.\n\nKeyword Arguments\n\ndecoding_type::EncoderType: Encoder decoding (:EncoderX1, :EncoderX2, :EncoderX4, :TwoPulseCounting).\nz_idx_enable::Bool: Enable Z-index.\nz_idx_val::Float64: Z-index value.\nz_idx_phase::ZIndexPhase: Z-index phase.\npulses_per_rev::UInt32: Pulses per revolution.\ninitial_angle::Float64: Initial angle value.\n\n\n\n\n\n","category":"method"},{"location":"#NIDAQmx.add_ci_count_edges!-Tuple{CITask, String}","page":"Home","title":"NIDAQmx.add_ci_count_edges!","text":"add_ci_count_edges!(task::CITask, counter::String;\n                    edge::Edge=Rising,\n                    initial_count::UInt32=UInt32(0),\n                    count_direction::CountDirection=CountUp,\n                    name::String=\"\")\n\nAdd a counter input channel that counts edges.\n\nArguments\n\ntask::CITask: The counter input task.\ncounter::String: Counter name (e.g., \"Dev1/ctr0\").\n\nKeyword Arguments\n\nedge::Edge: Which edge to count (default: Rising).\ninitial_count::UInt32: Starting count value (default: 0).\ncount_direction::CountDirection: Count direction (default: CountUp).\nname::String: Name to assign to the channel.\n\nExample\n\ntask = CITask()\nadd_ci_count_edges!(task, \"Dev1/ctr0\"; edge=Rising, count_direction=CountUp)\nconfigure_timing!(task; sample_mode=ContinuousSamples)\nstart!(task)\ncounts = read(task; samples_per_channel=100)\n\n\n\n\n\n","category":"method"},{"location":"#NIDAQmx.add_ci_freq!-Tuple{CITask, String}","page":"Home","title":"NIDAQmx.add_ci_freq!","text":"add_ci_freq!(task::CITask, counter::String;\n             min_val::Float64=1.0,\n             max_val::Float64=1000000.0,\n             units::Symbol=:Hz,\n             edge::Edge=Rising,\n             meas_method::Symbol=:LowFreq1Ctr,\n             meas_time::Float64=0.001,\n             divisor::UInt32=UInt32(4),\n             name::String=\"\",\n             custom_scale::String=\"\")\n\nAdd a counter input channel that measures frequency.\n\nKeyword Arguments\n\nmeas_method::Symbol: Measurement method (:LowFreq1Ctr, :HighFreq2Ctr, :LargeRng2Ctr).\nmeas_time::Float64: Measurement time for low frequency method (seconds).\ndivisor::UInt32: Divisor for high frequency method.\n\n\n\n\n\n","category":"method"},{"location":"#NIDAQmx.add_ci_lin_encoder!-Tuple{CITask, String}","page":"Home","title":"NIDAQmx.add_ci_lin_encoder!","text":"add_ci_lin_encoder!(task::CITask, counter::String;\n                    decoding_type::EncoderType=EncoderX4,\n                    z_idx_enable::Bool=false,\n                    z_idx_val::Float64=0.0,\n                    z_idx_phase::ZIndexPhase=AHighBHigh,\n                    units::Symbol=:Meters,\n                    dist_per_pulse::Float64=0.001,\n                    initial_pos::Float64=0.0,\n                    name::String=\"\",\n                    custom_scale::String=\"\")\n\nAdd a linear encoder input channel.\n\n\n\n\n\n","category":"method"},{"location":"#NIDAQmx.add_ci_period!-Tuple{CITask, String}","page":"Home","title":"NIDAQmx.add_ci_period!","text":"add_ci_period!(task::CITask, counter::String;\n               min_val::Float64=0.000001,\n               max_val::Float64=1.0,\n               units::Symbol=:Seconds,\n               edge::Edge=Rising,\n               meas_method::Symbol=:LowFreq1Ctr,\n               meas_time::Float64=0.001,\n               divisor::UInt32=UInt32(4),\n               name::String=\"\",\n               custom_scale::String=\"\")\n\nAdd a counter input channel that measures period.\n\n\n\n\n\n","category":"method"},{"location":"#NIDAQmx.add_ci_pulse_width!-Tuple{CITask, String}","page":"Home","title":"NIDAQmx.add_ci_pulse_width!","text":"add_ci_pulse_width!(task::CITask, counter::String;\n                    min_val::Float64=0.000001,\n                    max_val::Float64=1.0,\n                    units::Symbol=:Seconds,\n                    starting_edge::Edge=Rising,\n                    name::String=\"\",\n                    custom_scale::String=\"\")\n\nAdd a counter input channel that measures pulse width.\n\n\n\n\n\n","category":"method"},{"location":"#NIDAQmx.add_ci_two_edge_sep!-Tuple{CITask, String}","page":"Home","title":"NIDAQmx.add_ci_two_edge_sep!","text":"add_ci_two_edge_sep!(task::CITask, counter::String;\n                     min_val::Float64=0.000001,\n                     max_val::Float64=1.0,\n                     units::Symbol=:Seconds,\n                     first_edge::Edge=Rising,\n                     second_edge::Edge=Falling,\n                     name::String=\"\",\n                     custom_scale::String=\"\")\n\nAdd a counter input channel that measures time between two edges.\n\n\n\n\n\n","category":"method"},{"location":"#NIDAQmx.add_co_pulse_freq!-Tuple{COTask, String}","page":"Home","title":"NIDAQmx.add_co_pulse_freq!","text":"add_co_pulse_freq!(task::COTask, counter::String;\n                   units::Symbol=:Hz,\n                   idle_state::Level=Low,\n                   initial_delay::Float64=0.0,\n                   freq::Float64=1000.0,\n                   duty_cycle::Float64=0.5,\n                   name::String=\"\")\n\nAdd a counter output pulse channel using frequency and duty cycle.\n\nArguments\n\ntask::COTask: The counter output task.\ncounter::String: Counter name (e.g., \"Dev1/ctr0\").\n\nKeyword Arguments\n\nunits::Symbol: Frequency units (:Hz).\nidle_state::Level: Idle state (Low or High).\ninitial_delay::Float64: Initial delay before first pulse (seconds).\nfreq::Float64: Pulse frequency in Hz.\nduty_cycle::Float64: Duty cycle (0.0 to 1.0).\n\nExample\n\ntask = COTask()\nadd_co_pulse_freq!(task, \"Dev1/ctr0\"; freq=1000.0, duty_cycle=0.5)\nconfigure_timing!(task; sample_mode=ContinuousSamples, samples_per_channel=1000)\nstart!(task)\n\n\n\n\n\n","category":"method"},{"location":"#NIDAQmx.add_co_pulse_ticks!-Tuple{COTask, String}","page":"Home","title":"NIDAQmx.add_co_pulse_ticks!","text":"add_co_pulse_ticks!(task::COTask, counter::String;\n                    source_terminal::String=\"\",\n                    idle_state::Level=Low,\n                    initial_delay::Int32=Int32(0),\n                    low_ticks::Int32=Int32(100),\n                    high_ticks::Int32=Int32(100),\n                    name::String=\"\")\n\nAdd a counter output pulse channel using tick counts.\n\nKeyword Arguments\n\nsource_terminal::String: Source terminal for the timebase.\nlow_ticks::Int32: Number of ticks the pulse is low.\nhigh_ticks::Int32: Number of ticks the pulse is high.\n\n\n\n\n\n","category":"method"},{"location":"#NIDAQmx.add_co_pulse_time!-Tuple{COTask, String}","page":"Home","title":"NIDAQmx.add_co_pulse_time!","text":"add_co_pulse_time!(task::COTask, counter::String;\n                   units::Symbol=:Seconds,\n                   idle_state::Level=Low,\n                   initial_delay::Float64=0.0,\n                   low_time::Float64=0.001,\n                   high_time::Float64=0.001,\n                   name::String=\"\")\n\nAdd a counter output pulse channel using high/low times.\n\nKeyword Arguments\n\nlow_time::Float64: Time the pulse is low (seconds).\nhigh_time::Float64: Time the pulse is high (seconds).\n\n\n\n\n\n","category":"method"},{"location":"#NIDAQmx.add_di_chan!-Tuple{DITask, String}","page":"Home","title":"NIDAQmx.add_di_chan!","text":"add_di_chan!(task::DITask, lines::String;\n             line_grouping::LineGrouping=ChannelPerLine,\n             name::String=\"\")\n\nAdd digital input lines to the task.\n\nArguments\n\ntask::DITask: The digital input task.\nlines::String: Physical lines (e.g., \"Dev1/port0/line0:7\" or \"Dev1/port0\").\n\nKeyword Arguments\n\nline_grouping::LineGrouping: How to group lines (default: ChannelPerLine).\nChannelPerLine: Create one channel for each line.\nChannelForAllLines: Create one channel for all lines.\nname::String: Name to assign to the channel(s).\n\nExample\n\ntask = DITask()\nadd_di_chan!(task, \"Dev1/port0/line0:7\")\nstart!(task)\ndata = read(task)\n\n\n\n\n\n","category":"method"},{"location":"#NIDAQmx.add_do_chan!-Tuple{DOTask, String}","page":"Home","title":"NIDAQmx.add_do_chan!","text":"add_do_chan!(task::DOTask, lines::String;\n             line_grouping::LineGrouping=ChannelPerLine,\n             name::String=\"\")\n\nAdd digital output lines to the task.\n\nArguments\n\ntask::DOTask: The digital output task.\nlines::String: Physical lines (e.g., \"Dev1/port0/line0:7\" or \"Dev1/port0\").\n\nKeyword Arguments\n\nline_grouping::LineGrouping: How to group lines (default: ChannelPerLine).\nChannelPerLine: Create one channel for each line.\nChannelForAllLines: Create one channel for all lines.\nname::String: Name to assign to the channel(s).\n\nExample\n\ntask = DOTask()\nadd_do_chan!(task, \"Dev1/port0/line0:7\")\nwrite(task, UInt8[0xFF])\n\n\n\n\n\n","category":"method"},{"location":"#NIDAQmx.ai_channels-Tuple{Device}","page":"Home","title":"NIDAQmx.ai_channels","text":"ai_channels(device::Device) -> Vector{String}\nai_channels(device_name::String) -> Vector{String}\n\nGet a list of analog input physical channels available on the device.\n\nExample\n\njulia> ai_channels(\"Dev1\")\n[\"Dev1/ai0\", \"Dev1/ai1\", \"Dev1/ai2\", \"Dev1/ai3\"]\n\n\n\n\n\n","category":"method"},{"location":"#NIDAQmx.ai_current_ranges-Tuple{Device}","page":"Home","title":"NIDAQmx.ai_current_ranges","text":"ai_current_ranges(device::Device) -> Matrix{Float64}\nai_current_ranges(device_name::String) -> Matrix{Float64}\n\nGet the available current ranges for analog input channels.\n\n\n\n\n\n","category":"method"},{"location":"#NIDAQmx.ai_voltage_ranges-Tuple{Device}","page":"Home","title":"NIDAQmx.ai_voltage_ranges","text":"ai_voltage_ranges(device::Device) -> Matrix{Float64}\nai_voltage_ranges(device_name::String) -> Matrix{Float64}\n\nGet the available voltage ranges for analog input channels.\n\nReturns\n\nA matrix where each row is [min, max] for a voltage range.\n\nExample\n\njulia> ai_voltage_ranges(\"Dev1\")\n4×2 Matrix{Float64}:\n -10.0  10.0\n  -5.0   5.0\n  -1.0   1.0\n  -0.2   0.2\n\n\n\n\n\n","category":"method"},{"location":"#NIDAQmx.ao_channels-Tuple{Device}","page":"Home","title":"NIDAQmx.ao_channels","text":"ao_channels(device::Device) -> Vector{String}\nao_channels(device_name::String) -> Vector{String}\n\nGet a list of analog output physical channels available on the device.\n\n\n\n\n\n","category":"method"},{"location":"#NIDAQmx.ao_current_ranges-Tuple{Device}","page":"Home","title":"NIDAQmx.ao_current_ranges","text":"ao_current_ranges(device::Device) -> Matrix{Float64}\nao_current_ranges(device_name::String) -> Matrix{Float64}\n\nGet the available current ranges for analog output channels.\n\n\n\n\n\n","category":"method"},{"location":"#NIDAQmx.ao_voltage_ranges-Tuple{Device}","page":"Home","title":"NIDAQmx.ao_voltage_ranges","text":"ao_voltage_ranges(device::Device) -> Matrix{Float64}\nao_voltage_ranges(device_name::String) -> Matrix{Float64}\n\nGet the available voltage ranges for analog output channels.\n\n\n\n\n\n","category":"method"},{"location":"#NIDAQmx.available_samples-Tuple{NIDAQmx.Task}","page":"Home","title":"NIDAQmx.available_samples","text":"available_samples(task::Task) -> Int\n\nGet the number of samples available to read.\n\n\n\n\n\n","category":"method"},{"location":"#NIDAQmx.cached_library_version-Tuple{}","page":"Home","title":"NIDAQmx.cached_library_version","text":"cached_library_version() -> Union{Nothing, NIDAQmxVersion}\n\nGet the cached library version. Returns nothing if the library is not available. This is populated at module load time.\n\n\n\n\n\n","category":"method"},{"location":"#NIDAQmx.channel_names-Tuple{NIDAQmx.Task}","page":"Home","title":"NIDAQmx.channel_names","text":"channel_names(task::Task) -> Vector{String}\n\nGet the names of all channels in the task.\n\nReturns\n\nA vector of channel names.\n\n\n\n\n\n","category":"method"},{"location":"#NIDAQmx.channel_type-Tuple{NIDAQmx.Task, String}","page":"Home","title":"NIDAQmx.channel_type","text":"channel_type(task::Task, channel::String) -> Symbol\n\nGet the type of a channel (:AI, :AO, :DI, :DO, :CI, :CO).\n\n\n\n\n\n","category":"method"},{"location":"#NIDAQmx.check_error-Tuple{Int32}","page":"Home","title":"NIDAQmx.check_error","text":"check_error(code::Int32)\n\nCheck a NIDAQmx return code and handle errors/warnings appropriately.\n\nIf code == 0: Success, returns nothing.\nIf code > 0: Warning, logs a warning message and returns nothing.\nIf code < 0: Error, throws a NIDAQError exception.\n\nArguments\n\ncode::Int32: The return code from a NIDAQmx function.\n\nThrows\n\nNIDAQError: If code < 0.\n\n\n\n\n\n","category":"method"},{"location":"#NIDAQmx.ci_channels-Tuple{Device}","page":"Home","title":"NIDAQmx.ci_channels","text":"ci_channels(device::Device) -> Vector{String}\nci_channels(device_name::String) -> Vector{String}\n\nGet a list of counter input physical channels available on the device.\n\n\n\n\n\n","category":"method"},{"location":"#NIDAQmx.clear!-Tuple{NIDAQmx.Task}","page":"Home","title":"NIDAQmx.clear!","text":"clear!(task::Task)\n\nClear the specified task, releasing all resources associated with it. After clearing, the task handle is no longer valid.\n\nArguments\n\ntask::Task: The task to clear.\n\nNote\n\nThis is typically called automatically by the finalizer, but can be called explicitly if you want to release resources immediately.\n\n\n\n\n\n","category":"method"},{"location":"#NIDAQmx.co_channels-Tuple{Device}","page":"Home","title":"NIDAQmx.co_channels","text":"co_channels(device::Device) -> Vector{String}\nco_channels(device_name::String) -> Vector{String}\n\nGet a list of counter output physical channels available on the device.\n\n\n\n\n\n","category":"method"},{"location":"#NIDAQmx.configure_analog_ref_trigger!-Tuple{NIDAQmx.Task, String}","page":"Home","title":"NIDAQmx.configure_analog_ref_trigger!","text":"configure_analog_ref_trigger!(task::Task, source::String;\n                              slope::Slope=RisingSlope,\n                              level::Float64=0.0,\n                              pretrigger_samples::Int=100)\n\nConfigure an analog edge reference trigger.\n\n\n\n\n\n","category":"method"},{"location":"#NIDAQmx.configure_analog_start_trigger!-Tuple{NIDAQmx.Task, String}","page":"Home","title":"NIDAQmx.configure_analog_start_trigger!","text":"configure_analog_start_trigger!(task::Task, source::String;\n                                slope::Slope=RisingSlope,\n                                level::Float64=0.0)\n\nConfigure an analog edge start trigger for the task.\n\nArguments\n\ntask::Task: The task to configure.\nsource::String: Trigger source channel (e.g., \"Dev1/ai0\").\nslope::Slope: Trigger slope (RisingSlope or FallingSlope).\nlevel::Float64: Trigger level in volts.\n\n\n\n\n\n","category":"method"},{"location":"#NIDAQmx.configure_analog_window_start_trigger!-Tuple{NIDAQmx.Task, String}","page":"Home","title":"NIDAQmx.configure_analog_window_start_trigger!","text":"configure_analog_window_start_trigger!(task::Task, source::String;\n                                       when::Symbol=:EnteringWindow,\n                                       window_top::Float64=1.0,\n                                       window_bottom::Float64=-1.0)\n\nConfigure an analog window start trigger for the task.\n\nKeyword Arguments\n\nwhen::Symbol: When to trigger (:EnteringWindow or :LeavingWindow).\nwindow_top::Float64: Top of the trigger window.\nwindow_bottom::Float64: Bottom of the trigger window.\n\n\n\n\n\n","category":"method"},{"location":"#NIDAQmx.configure_change_detection_timing!-Tuple{DITask}","page":"Home","title":"NIDAQmx.configure_change_detection_timing!","text":"configure_change_detection_timing!(task::DITask;\n                                   rising_edge_channels::String=\"\",\n                                   falling_edge_channels::String=\"\",\n                                   sample_mode::SampleMode=FiniteSamples,\n                                   samples_per_channel::Int=1000)\n\nConfigure change detection timing for digital input tasks. The task will generate a sample when a change is detected on the specified channels.\n\nKeyword Arguments\n\nrising_edge_channels::String: Channels to detect rising edges on.\nfalling_edge_channels::String: Channels to detect falling edges on.\n\n\n\n\n\n","category":"method"},{"location":"#NIDAQmx.configure_digital_ref_trigger!-Tuple{NIDAQmx.Task, String}","page":"Home","title":"NIDAQmx.configure_digital_ref_trigger!","text":"configure_digital_ref_trigger!(task::Task, source::String;\n                               edge::Edge=Rising,\n                               pretrigger_samples::Int=100)\n\nConfigure a digital edge reference trigger.\n\nArguments\n\nsource::String: Trigger source terminal.\nedge::Edge: Edge to trigger on.\npretrigger_samples::Int: Number of samples to acquire before the trigger.\n\n\n\n\n\n","category":"method"},{"location":"#NIDAQmx.configure_digital_start_trigger!-Tuple{NIDAQmx.Task, String}","page":"Home","title":"NIDAQmx.configure_digital_start_trigger!","text":"configure_digital_start_trigger!(task::Task, source::String;\n                                 edge::Edge=Rising)\n\nConfigure a digital edge start trigger for the task.\n\nArguments\n\ntask::Task: The task to configure.\nsource::String: Trigger source terminal (e.g., \"/Dev1/PFI0\").\nedge::Edge: Edge to trigger on (Rising or Falling).\n\nExample\n\ntask = AITask(\"Dev1/ai0\")\nconfigure_timing!(task; rate=10000.0, samples_per_channel=1000)\nconfigure_digital_start_trigger!(task, \"/Dev1/PFI0\"; edge=Rising)\nstart!(task)  # Task will wait for trigger\n\n\n\n\n\n","category":"method"},{"location":"#NIDAQmx.configure_handshaking_timing!-Tuple{NIDAQmx.Task}","page":"Home","title":"NIDAQmx.configure_handshaking_timing!","text":"configure_handshaking_timing!(task::Task;\n                              sample_mode::SampleMode=FiniteSamples,\n                              samples_per_channel::Int=1000)\n\nConfigure handshaking timing for a task.\n\n\n\n\n\n","category":"method"},{"location":"#NIDAQmx.configure_implicit_timing!-Tuple{NIDAQmx.Task}","page":"Home","title":"NIDAQmx.configure_implicit_timing!","text":"configure_implicit_timing!(task::Task;\n                           sample_mode::SampleMode=FiniteSamples,\n                           samples_per_channel::Int=1000)\n\nConfigure implicit timing for tasks that don't use a sample clock. This is typically used for counter output tasks.\n\nExample\n\ntask = COTask(\"Dev1/ctr0\"; freq=1000.0, duty_cycle=0.5)\nconfigure_implicit_timing!(task; sample_mode=ContinuousSamples, samples_per_channel=1000)\nstart!(task)\n\n\n\n\n\n","category":"method"},{"location":"#NIDAQmx.configure_input_buffer!-Tuple{NIDAQmx.Task, Int64}","page":"Home","title":"NIDAQmx.configure_input_buffer!","text":"configure_input_buffer!(task::Task, samples_per_channel::Int)\n\nConfigure the size of the input buffer.\n\n\n\n\n\n","category":"method"},{"location":"#NIDAQmx.configure_output_buffer!-Tuple{NIDAQmx.Task, Int64}","page":"Home","title":"NIDAQmx.configure_output_buffer!","text":"configure_output_buffer!(task::Task, samples_per_channel::Int)\n\nConfigure the size of the output buffer.\n\n\n\n\n\n","category":"method"},{"location":"#NIDAQmx.configure_timing!-Tuple{NIDAQmx.Task}","page":"Home","title":"NIDAQmx.configure_timing!","text":"configure_timing!(task::Task;\n                  source::String=\"\",\n                  rate::Float64=1000.0,\n                  active_edge::Edge=Rising,\n                  sample_mode::SampleMode=FiniteSamples,\n                  samples_per_channel::Int=1000)\n\nConfigure sample clock timing for a task.\n\nArguments\n\ntask::Task: The task to configure.\n\nKeyword Arguments\n\nsource::String: Source terminal for the sample clock (default: \"\" for internal clock).\nrate::Float64: Sample rate in samples per second (default: 1000.0).\nactive_edge::Edge: Edge to use for sampling (Rising or Falling).\nsample_mode::SampleMode: Sampling mode:\nFiniteSamples: Acquire a finite number of samples.\nContinuousSamples: Acquire continuously until stopped.\nHardwareTimedSinglePoint: Hardware-timed single point.\nsamples_per_channel::Int: Number of samples per channel to acquire/generate.\n\nExample\n\ntask = AITask(\"Dev1/ai0\")\nconfigure_timing!(task; rate=10000.0, samples_per_channel=1000, sample_mode=FiniteSamples)\n\n\n\n\n\n","category":"method"},{"location":"#NIDAQmx.control!-Tuple{NIDAQmx.Task, Symbol}","page":"Home","title":"NIDAQmx.control!","text":"control!(task::Task, action::Symbol)\n\nPerform a control action on the task.\n\nArguments\n\ntask::Task: The task to control.\naction::Symbol: The action to perform. One of:\n:start: Start the task\n:stop: Stop the task\n:verify: Verify the task configuration\n:commit: Commit the task (transition to committed state)\n:reserve: Reserve task resources\n:unreserve: Unreserve task resources\n:abort: Abort the task\n\nThrows\n\nNIDAQError: If the action fails.\nArgumentError: If the action is not recognized.\n\n\n\n\n\n","category":"method"},{"location":"#NIDAQmx.create_task","page":"Home","title":"NIDAQmx.create_task","text":"create_task(name::String=\"\") -> TaskHandle\n\nCreate a new NIDAQmx task and return its handle.\n\n\n\n\n\n","category":"function"},{"location":"#NIDAQmx.device_names-Tuple{NIDAQmx.Task}","page":"Home","title":"NIDAQmx.device_names","text":"device_names(task::Task) -> Vector{String}\n\nGet the names of all devices used by the task.\n\nReturns\n\nA vector of device names.\n\n\n\n\n\n","category":"method"},{"location":"#NIDAQmx.device_names-Tuple{}","page":"Home","title":"NIDAQmx.device_names","text":"device_names() -> Vector{String}\n\nGet a list of all available device names as strings.\n\n\n\n\n\n","category":"method"},{"location":"#NIDAQmx.devices-Tuple{}","page":"Home","title":"NIDAQmx.devices","text":"devices() -> Vector{Device}\n\nGet a list of all available NIDAQmx devices.\n\nReturns\n\nA vector of Device objects representing available devices.\n\nExample\n\njulia> devs = devices()\n2-element Vector{Device}:\n Device(\"Dev1\")\n Device(\"Dev2\")\n\njulia> ai_channels(devs[1])\n[\"Dev1/ai0\", \"Dev1/ai1\", ...]\n\n\n\n\n\n","category":"method"},{"location":"#NIDAQmx.di_lines-Tuple{Device}","page":"Home","title":"NIDAQmx.di_lines","text":"di_lines(device::Device) -> Vector{String}\ndi_lines(device_name::String) -> Vector{String}\n\nGet a list of digital input lines available on the device.\n\n\n\n\n\n","category":"method"},{"location":"#NIDAQmx.di_ports-Tuple{Device}","page":"Home","title":"NIDAQmx.di_ports","text":"di_ports(device::Device) -> Vector{String}\ndi_ports(device_name::String) -> Vector{String}\n\nGet a list of digital input ports available on the device.\n\n\n\n\n\n","category":"method"},{"location":"#NIDAQmx.disable_ref_trigger!-Tuple{NIDAQmx.Task}","page":"Home","title":"NIDAQmx.disable_ref_trigger!","text":"disable_ref_trigger!(task::Task)\n\nDisable the reference trigger for a task.\n\n\n\n\n\n","category":"method"},{"location":"#NIDAQmx.disable_start_trigger!-Tuple{NIDAQmx.Task}","page":"Home","title":"NIDAQmx.disable_start_trigger!","text":"disable_start_trigger!(task::Task)\n\nDisable the start trigger for a task.\n\n\n\n\n\n","category":"method"},{"location":"#NIDAQmx.do_lines-Tuple{Device}","page":"Home","title":"NIDAQmx.do_lines","text":"do_lines(device::Device) -> Vector{String}\ndo_lines(device_name::String) -> Vector{String}\n\nGet a list of digital output lines available on the device.\n\n\n\n\n\n","category":"method"},{"location":"#NIDAQmx.do_ports-Tuple{Device}","page":"Home","title":"NIDAQmx.do_ports","text":"do_ports(device::Device) -> Vector{String}\ndo_ports(device_name::String) -> Vector{String}\n\nGet a list of digital output ports available on the device.\n\n\n\n\n\n","category":"method"},{"location":"#NIDAQmx.get_all_channel_properties-Tuple{NIDAQmx.Task, String}","page":"Home","title":"NIDAQmx.get_all_channel_properties","text":"get_all_channel_properties(task::Task, channel::String) -> Dict{Symbol, Any}\n\nGet all readable properties for a channel.\n\n\n\n\n\n","category":"method"},{"location":"#NIDAQmx.get_channel_property-Tuple{NIDAQmx.Task, String, Symbol}","page":"Home","title":"NIDAQmx.get_channel_property","text":"get_channel_property(task::Task, channel::String, property::Symbol)\n\nGet a property value for a specific channel.\n\nExample\n\ntask = AITask(\"Dev1/ai0\")\nmax_val = get_channel_property(task, \"Dev1/ai0\", :ai_max)\n\n\n\n\n\n","category":"method"},{"location":"#NIDAQmx.get_error_message-Tuple{Int32}","page":"Home","title":"NIDAQmx.get_error_message","text":"get_error_message(code::Int32) -> String\n\nRetrieve the error message string for a given NIDAQmx error or warning code.\n\n\n\n\n\n","category":"method"},{"location":"#NIDAQmx.get_extended_error_info-Tuple{}","page":"Home","title":"NIDAQmx.get_extended_error_info","text":"get_extended_error_info() -> String\n\nRetrieve extended error information for the last error that occurred. This provides more detailed context than get_error_message.\n\n\n\n\n\n","category":"method"},{"location":"#NIDAQmx.get_task_property-Tuple{NIDAQmx.Task, Symbol}","page":"Home","title":"NIDAQmx.get_task_property","text":"get_task_property(task::Task, property::Symbol)\n\nGet a property value for a task.\n\n\n\n\n\n","category":"method"},{"location":"#NIDAQmx.input_buffer_size-Tuple{NIDAQmx.Task}","page":"Home","title":"NIDAQmx.input_buffer_size","text":"input_buffer_size(task::Task) -> Int\n\nGet the input buffer size per channel.\n\n\n\n\n\n","category":"method"},{"location":"#NIDAQmx.is_done-Tuple{NIDAQmx.Task}","page":"Home","title":"NIDAQmx.is_done","text":"is_done(task::Task) -> Bool\n\nCheck if the task has completed all operations.\n\nArguments\n\ntask::Task: The task to check.\n\nReturns\n\ntrue if the task is done, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"#NIDAQmx.is_library_available-Tuple{}","page":"Home","title":"NIDAQmx.is_library_available","text":"is_library_available() -> Bool\n\nCheck if the NIDAQmx library is available on the system.\n\nReturns\n\ntrue if the library can be loaded, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"#NIDAQmx.is_simulated-Tuple{Device}","page":"Home","title":"NIDAQmx.is_simulated","text":"is_simulated(device::Device) -> Bool\nis_simulated(device_name::String) -> Bool\n\nCheck if a device is a simulated device.\n\n\n\n\n\n","category":"method"},{"location":"#NIDAQmx.is_valid-Tuple{NIDAQmx.Task}","page":"Home","title":"NIDAQmx.is_valid","text":"is_valid(task::Task) -> Bool\n\nCheck if a task has a valid (non-null) handle.\n\n\n\n\n\n","category":"method"},{"location":"#NIDAQmx.library_version-Tuple{}","page":"Home","title":"NIDAQmx.library_version","text":"library_version() -> NIDAQmxVersion\n\nQuery the installed NIDAQmx driver version.\n\nReturns\n\nNIDAQmxVersion: The version of the installed NIDAQmx driver.\n\nThrows\n\nNIDAQError: If the version cannot be determined.\n\nExample\n\njulia> v = library_version()\nNIDAQmx v23.5.0\n\njulia> VersionNumber(v)\nv\"23.5.0\"\n\n\n\n\n\n","category":"method"},{"location":"#NIDAQmx.list_channel_properties-Tuple{}","page":"Home","title":"NIDAQmx.list_channel_properties","text":"list_channel_properties() -> Vector{Symbol}\n\nList all available channel properties.\n\n\n\n\n\n","category":"method"},{"location":"#NIDAQmx.list_task_properties-Tuple{}","page":"Home","title":"NIDAQmx.list_task_properties","text":"list_task_properties() -> Vector{Symbol}\n\nList all available task properties.\n\n\n\n\n\n","category":"method"},{"location":"#NIDAQmx.measurement_type-Tuple{NIDAQmx.Task, String}","page":"Home","title":"NIDAQmx.measurement_type","text":"measurement_type(task::Task, channel::String) -> Int32\n\nGet the measurement or output type for a channel. Returns the NIDAQmx constant value.\n\n\n\n\n\n","category":"method"},{"location":"#NIDAQmx.num_channels-Tuple{NIDAQmx.Task}","page":"Home","title":"NIDAQmx.num_channels","text":"num_channels(task::Task) -> Int\n\nGet the number of channels in the task.\n\nArguments\n\ntask::Task: The task to query.\n\nReturns\n\nThe number of channels in the task.\n\n\n\n\n\n","category":"method"},{"location":"#NIDAQmx.output_buffer_size-Tuple{NIDAQmx.Task}","page":"Home","title":"NIDAQmx.output_buffer_size","text":"output_buffer_size(task::Task) -> Int\n\nGet the output buffer size per channel.\n\n\n\n\n\n","category":"method"},{"location":"#NIDAQmx.product_number-Tuple{Device}","page":"Home","title":"NIDAQmx.product_number","text":"product_number(device::Device) -> UInt32\nproduct_number(device_name::String) -> UInt32\n\nGet the product number of a device.\n\n\n\n\n\n","category":"method"},{"location":"#NIDAQmx.product_type-Tuple{Device}","page":"Home","title":"NIDAQmx.product_type","text":"product_type(device::Device) -> String\nproduct_type(device_name::String) -> String\n\nGet the product type of a device (e.g., \"USB-6001\").\n\n\n\n\n\n","category":"method"},{"location":"#NIDAQmx.property_info-Tuple{Symbol}","page":"Home","title":"NIDAQmx.property_info","text":"property_info(property::Symbol) -> PropertyDef\n\nGet information about a property.\n\n\n\n\n\n","category":"method"},{"location":"#NIDAQmx.read_scalar-Tuple{AITask}","page":"Home","title":"NIDAQmx.read_scalar","text":"read_scalar(task::AITask; timeout::Float64=10.0) -> Float64\n\nRead a single sample from an analog input task.\n\n\n\n\n\n","category":"method"},{"location":"#NIDAQmx.read_scalar-Tuple{CITask}","page":"Home","title":"NIDAQmx.read_scalar","text":"read_scalar(task::CITask; timeout::Float64=10.0) -> UInt32\n\nRead a single counter value.\n\n\n\n\n\n","category":"method"},{"location":"#NIDAQmx.read_scalar-Tuple{DITask}","page":"Home","title":"NIDAQmx.read_scalar","text":"read_scalar(task::DITask; timeout::Float64=10.0) -> UInt32\n\nRead a single digital sample.\n\n\n\n\n\n","category":"method"},{"location":"#NIDAQmx.reset!-Tuple{Device}","page":"Home","title":"NIDAQmx.reset!","text":"reset!(device::Device)\nreset!(device_name::String)\n\nReset the device to its default state.\n\n\n\n\n\n","category":"method"},{"location":"#NIDAQmx.sample_clock_source-Tuple{NIDAQmx.Task}","page":"Home","title":"NIDAQmx.sample_clock_source","text":"sample_clock_source(task::Task) -> String\n\nGet the sample clock source terminal.\n\n\n\n\n\n","category":"method"},{"location":"#NIDAQmx.sample_rate-Tuple{NIDAQmx.Task}","page":"Home","title":"NIDAQmx.sample_rate","text":"sample_rate(task::Task) -> Float64\n\nGet the sample clock rate for a task.\n\n\n\n\n\n","category":"method"},{"location":"#NIDAQmx.samples_per_channel-Tuple{NIDAQmx.Task}","page":"Home","title":"NIDAQmx.samples_per_channel","text":"samples_per_channel(task::Task) -> Int\n\nGet the number of samples per channel for the task.\n\n\n\n\n\n","category":"method"},{"location":"#NIDAQmx.self_calibrate!-Tuple{Device}","page":"Home","title":"NIDAQmx.self_calibrate!","text":"self_calibrate!(device::Device)\nself_calibrate!(device_name::String)\n\nPerform self-calibration on the device.\n\n\n\n\n\n","category":"method"},{"location":"#NIDAQmx.serial_number-Tuple{Device}","page":"Home","title":"NIDAQmx.serial_number","text":"serial_number(device::Device) -> UInt32\nserial_number(device_name::String) -> UInt32\n\nGet the serial number of a device.\n\n\n\n\n\n","category":"method"},{"location":"#NIDAQmx.set_channel_property!-Tuple{NIDAQmx.Task, String, Symbol, Any}","page":"Home","title":"NIDAQmx.set_channel_property!","text":"set_channel_property!(task::Task, channel::String, property::Symbol, value)\n\nSet a property value for a specific channel.\n\nExample\n\ntask = AITask(\"Dev1/ai0\")\nset_channel_property!(task, \"Dev1/ai0\", :ai_max, 5.0)\n\n\n\n\n\n","category":"method"},{"location":"#NIDAQmx.set_input_buffer_size!-Tuple{NIDAQmx.Task, Int64}","page":"Home","title":"NIDAQmx.set_input_buffer_size!","text":"set_input_buffer_size!(task::Task, size::Int)\n\nSet the input buffer size per channel.\n\n\n\n\n\n","category":"method"},{"location":"#NIDAQmx.set_output_buffer_size!-Tuple{NIDAQmx.Task, Int64}","page":"Home","title":"NIDAQmx.set_output_buffer_size!","text":"set_output_buffer_size!(task::Task, size::Int)\n\nSet the output buffer size per channel.\n\n\n\n\n\n","category":"method"},{"location":"#NIDAQmx.set_sample_clock_source!-Tuple{NIDAQmx.Task, String}","page":"Home","title":"NIDAQmx.set_sample_clock_source!","text":"set_sample_clock_source!(task::Task, source::String)\n\nSet the sample clock source terminal.\n\n\n\n\n\n","category":"method"},{"location":"#NIDAQmx.set_sample_rate!-Tuple{NIDAQmx.Task, Float64}","page":"Home","title":"NIDAQmx.set_sample_rate!","text":"set_sample_rate!(task::Task, rate::Float64)\n\nSet the sample clock rate for a task.\n\n\n\n\n\n","category":"method"},{"location":"#NIDAQmx.set_samples_per_channel!-Tuple{NIDAQmx.Task, Int64}","page":"Home","title":"NIDAQmx.set_samples_per_channel!","text":"set_samples_per_channel!(task::Task, count::Int)\n\nSet the number of samples per channel for the task.\n\n\n\n\n\n","category":"method"},{"location":"#NIDAQmx.set_task_property!-Tuple{NIDAQmx.Task, Symbol, Any}","page":"Home","title":"NIDAQmx.set_task_property!","text":"set_task_property!(task::Task, property::Symbol, value)\n\nSet a property value for a task.\n\n\n\n\n\n","category":"method"},{"location":"#NIDAQmx.space_available-Tuple{NIDAQmx.Task}","page":"Home","title":"NIDAQmx.space_available","text":"space_available(task::Task) -> Int\n\nGet the amount of space available in the output buffer.\n\n\n\n\n\n","category":"method"},{"location":"#NIDAQmx.start!-Tuple{NIDAQmx.Task}","page":"Home","title":"NIDAQmx.start!","text":"start!(task::Task)\n\nStart the specified task. The task begins performing its configured operations.\n\nArguments\n\ntask::Task: The task to start.\n\nThrows\n\nNIDAQError: If the task cannot be started.\n\nExample\n\ntask = AITask(\"Dev1/ai0\")\nconfigure_timing!(task; rate=1000.0, samples_per_channel=100)\nstart!(task)\ndata = read(task)\nstop!(task)\n\n\n\n\n\n","category":"method"},{"location":"#NIDAQmx.stop!-Tuple{NIDAQmx.Task}","page":"Home","title":"NIDAQmx.stop!","text":"stop!(task::Task)\n\nStop the specified task. The task stops performing its operations but remains configured.\n\nArguments\n\ntask::Task: The task to stop.\n\nThrows\n\nNIDAQError: If the task cannot be stopped.\n\n\n\n\n\n","category":"method"},{"location":"#NIDAQmx.task_handle-Tuple{NIDAQmx.Task}","page":"Home","title":"NIDAQmx.task_handle","text":"task_handle(task::Task) -> TaskHandle\n\nGet the underlying NIDAQmx handle for a task.\n\n\n\n\n\n","category":"method"},{"location":"#NIDAQmx.task_kind-Union{Tuple{NIDAQmx.Task{K}}, Tuple{K}} where K","page":"Home","title":"NIDAQmx.task_kind","text":"task_kind(::Task{K}) where K\n\nGet the task kind type parameter.\n\n\n\n\n\n","category":"method"},{"location":"#NIDAQmx.task_name-Tuple{NIDAQmx.Task}","page":"Home","title":"NIDAQmx.task_name","text":"task_name(task::Task) -> String\n\nGet the name of the task.\n\n\n\n\n\n","category":"method"},{"location":"#NIDAQmx.terminals-Tuple{Device}","page":"Home","title":"NIDAQmx.terminals","text":"terminals(device::Device) -> Vector{String}\nterminals(device_name::String) -> Vector{String}\n\nGet a list of terminals available on the device.\n\n\n\n\n\n","category":"method"},{"location":"#NIDAQmx.total_samples_acquired-Tuple{NIDAQmx.Task}","page":"Home","title":"NIDAQmx.total_samples_acquired","text":"total_samples_acquired(task::Task) -> Int\n\nGet the total number of samples acquired per channel.\n\n\n\n\n\n","category":"method"},{"location":"#NIDAQmx.total_samples_generated-Tuple{NIDAQmx.Task}","page":"Home","title":"NIDAQmx.total_samples_generated","text":"total_samples_generated(task::Task) -> Int\n\nGet the total number of samples generated per channel.\n\n\n\n\n\n","category":"method"},{"location":"#NIDAQmx.wait_until_done-Tuple{NIDAQmx.Task}","page":"Home","title":"NIDAQmx.wait_until_done","text":"wait_until_done(task::Task; timeout::Float64=-1.0)\n\nWait until the task has completed all operations.\n\nArguments\n\ntask::Task: The task to wait on.\ntimeout::Float64: Maximum time to wait in seconds. Use -1.0 to wait indefinitely.\n\nThrows\n\nNIDAQError: If the wait times out or encounters an error.\n\nExample\n\ntask = AOTask(\"Dev1/ao0\")\nconfigure_timing!(task; rate=1000.0, samples_per_channel=100)\nwrite(task, data)\nstart!(task)\nwait_until_done(task)\nstop!(task)\n\n\n\n\n\n","category":"method"},{"location":"#NIDAQmx.write_scalar-Tuple{AOTask, Float64}","page":"Home","title":"NIDAQmx.write_scalar","text":"write_scalar(task::AOTask, value::Float64; auto_start::Bool=true, timeout::Float64=10.0)\n\nWrite a single voltage value to an analog output task.\n\n\n\n\n\n","category":"method"},{"location":"#NIDAQmx.write_scalar-Tuple{DOTask, UInt32}","page":"Home","title":"NIDAQmx.write_scalar","text":"write_scalar(task::DOTask, value::UInt32; auto_start::Bool=true, timeout::Float64=10.0)\n\nWrite a single digital value to a digital output task.\n\n\n\n\n\n","category":"method"},{"location":"#NIDAQmx.@check-Tuple{Any}","page":"Home","title":"NIDAQmx.@check","text":"@check expr\n\nMacro to check the return code of a NIDAQmx function call.\n\nExample\n\n@check DAQmxStartTask(task.handle)\n\n\n\n\n\n","category":"macro"}]
}
